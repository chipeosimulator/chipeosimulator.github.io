<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Chipeo Simulator - Juego de Autos y M√∫sica Online</title>
    <meta name="description"
        content="Juega Chipeo Simulator online. Conduce autos modificados, pon m√∫sica a todo volumen con Bass Boost y re√∫nete con amigos en este simulador de chipeo multiplayer.">
    <meta name="keywords"
        content="chipeo simulator, chipeo simulador, juego de autos, musica, bass boost, chipeo, multiplayer, autos bajos, sonido, republica dominicana, car audio game">
    <meta name="author" content="Chipeo Simulator Team">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://chipeosimulador.github.io/">
    <meta property="og:title" content="Chipeo Simulator - Juego de Autos y M√∫sica">
    <meta property="og:description"
        content="El mejor simulador de Chipeo Online. Autos, M√∫sica y Amigos. ¬°Entra y suena tu m√∫sica!">
    <meta property="og:image" content="https://raw.githubusercontent.com/chipeosimulator/Modelos/main/thumbnail.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://chipeosimulador.github.io/">
    <meta property="twitter:title" content="Chipeo Simulator - Juego de Autos y M√∫sica">
    <meta property="twitter:description"
        content="El mejor simulador de Chipeo Online. Autos, M√∫sica y Amigos. ¬°Entra y suena tu m√∫sica!">
    <meta property="twitter:image"
        content="https://raw.githubusercontent.com/chipeosimulator/Modelos/main/thumbnail.png">
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/chipeosimulator/Modelos/main/logo.png">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            font-family: sans-serif;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            display: none;
        }

        #musicMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            color: white;
            display: none;
            min-width: 400px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            z-index: 2000;
        }

        #musicMenu h2 {
            margin-top: 0;
            color: #00ff88;
            text-align: center;
        }

        #musicMenu input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #00ff88;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 14px;
            box-sizing: border-box;
        }

        #musicMenu button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        #playBtn {
            background: #00ff88;
            color: black;
            font-weight: bold;
        }

        #playBtn:hover {
            background: #00cc6a;
            transform: scale(1.05);
        }

        #stopBtn {
            background: #ff4444;
            color: white;
        }

        #stopBtn:hover {
            background: #cc0000;
        }

        #closeBtn {
            background: #666;
            color: white;
        }

        #closeBtn:hover {
            background: #888;
        }

        .musicStatus {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 5px;
            text-align: center;
        }

        .volumeControl {
            margin: 15px 0;
        }

        .volumeControl label {
            display: block;
            margin-bottom: 5px;
            color: #00ff88;
        }

        .volumeControl input[type="range"] {
            width: 100%;
        }

        .bassIndicator {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 0, 100, 0.2);
            border-radius: 5px;
            text-align: center;
            color: #ff0066;
            font-weight: bold;
        }

        .loading {
            display: inline-block;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Login Menu */
        #loginMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #00ff88;
            color: white;
            min-width: 500px;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.7);
            z-index: 2002;
        }

        #loginMenu h2 {
            margin-top: 0;
            color: #00ff88;
            text-align: center;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #loginMenu input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: rgba(0, 100, 50, 0.2);
            color: white;
            font-size: 18px;
            box-sizing: border-box;
            text-align: center;
        }

        #loginMenu input:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        #joinBtn {
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: black;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
        }

        #joinBtn:hover {
            background: linear-gradient(135deg, #00cc6a, #00aa55);
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.5);
        }

        /* Players Panel */
        #playersPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            color: white;
            min-width: 200px;
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        #playersPanel h3 {
            margin: 0 0 10px 0;
            color: #00ff88;
            text-align: center;
            font-size: 16px;
        }

        .player-item {
            background: rgba(0, 255, 136, 0.1);
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #00ff88;
            font-size: 14px;
        }

        .player-item.self {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        .player-name {
            font-weight: bold;
            color: #00ff88;
        }

        .player-item.self .player-name {
            color: #ffaa00;
        }

        .player-status {
            font-size: 11px;
            color: #aaa;
            margin-top: 3px;
        }

        /* Coordenadas para ubicaci√≥n de props */
        #coordsDisplay {
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 5px;
            font-family: monospace;
            color: #00ff88;
            display: none;
        }

        /* Men√∫ de Configuraci√≥n Gr√°fica */
        #graphicsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            color: white;
            display: none;
            min-width: 400px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            z-index: 2001;
        }

        #graphicsMenu h2 {
            margin-top: 0;
            color: #00ff88;
            text-align: center;
        }

        .quality-option {
            background: rgba(0, 255, 136, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border: 2px solid #00ff88;
            cursor: pointer;
            transition: all 0.3s;
        }

        .quality-option:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: scale(1.02);
        }

        .quality-option.selected {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .quality-option h3 {
            margin: 0 0 5px 0;
            color: #00ff88;
        }

        .quality-option p {
            margin: 5px 0 0 0;
            font-size: 12px;
            color: #aaa;
        }

        #closeGraphicsBtn {
            width: 100%;
            padding: 10px;
            margin-top: 15px;
            border: none;
            border-radius: 5px;
            background: #666;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        #closeGraphicsBtn:hover {
            background: #888;
        }

        /* Barra de Nitro - Minimalista */
        #nitroBarContainer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            display: none;
            z-index: 100;
            overflow: hidden;
        }

        #nitroBar {
            width: 100%;
            height: 100%;
            background: #00ff88;
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        #nitroBarContainer.active #nitroBar {
            background: #00ff00;
        }

        /* Efecto de velocidad */
        #speedEffect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 999;
        }

        #speedEffect.active {
            opacity: 1;
        }

        #speedEffect::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 0%, rgba(0, 255, 136, 0.1) 50%, rgba(0, 255, 136, 0.2) 100%);
            animation: speedLines 0.1s linear infinite;
        }

        @keyframes speedLines {
            0% {
                transform: translateY(0) scaleY(1);
            }

            100% {
                transform: translateY(-20px) scaleY(1.1);
            }
        }

        /* CONTROLES M√ìVILES */
        #mobileControls {
            display: none;
            /* Se activa con JS si es m√≥vil */
            pointer-events: none;
            /* Permitir clicks passthrough donde no hay botones */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
        }

        #joystickZone {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
            /* El joystick debe capturar toques */
        }

        #mobileActionBtn {
            position: absolute;
            bottom: 80px;
            right: 50px;
            width: 80px;
            height: 80px;
            background: rgba(0, 255, 136, 0.5);
            border: 2px solid #fff;
            border-radius: 50%;
            color: white;
            font-size: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }

        #mobileActionBtn:active {
            background: rgba(0, 255, 136, 0.8);
            transform: scale(0.95);
        }

        /* Bot√≥n espec√≠fico para entrar al auto (Puerta) */
        #mobileEnterBtn {
            position: absolute;
            bottom: 180px;
            /* Encima del bot√≥n de acci√≥n */
            right: 200px;
            width: 70px;
            height: 70px;
            background: rgba(255, 200, 0, 0.6);
            border: 2px solid #fff;
            border-radius: 50%;
            font-size: 35px;
            display: flex;
            /* Flex para centrar */
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
            display: none;
            /* Oculto por defecto, se muestra cerca de un auto */
            z-index: 1001;
        }

        /* Controles de Auto Mejorados */
        #mobileCarControls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .car-btn {
            position: absolute;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            border-radius: 15px;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            user-select: none;
            touch-action: manipulation;
        }

        .car-btn:active {
            background: rgba(255, 255, 255, 0.5);
        }

        /* Direcci√≥n (Izquierda/Derecha) */
        #btnLeft {
            bottom: 30px;
            left: 20px;
        }

        #btnRight {
            bottom: 30px;
            left: 120px;
        }

        /* Pedales (Acelerar/Frenar) */
        #btnBrake {
            bottom: 30px;
            right: 120px;
            background: rgba(255, 50, 50, 0.3);
            font-size: 30px;
        }

        #btnGas {
            bottom: 30px;
            right: 20px;
            background: rgba(50, 255, 50, 0.3);
            font-size: 30px;
        }

        #btnNitro {
            bottom: 220px;
            right: 20px;
            width: 60px;
            height: 60px;
            font-size: 25px;
            background: rgba(0, 200, 255, 0.4);
            border-radius: 50%;
        }

        /* √Årea t√°ctil derecha para rotar c√°mara */
        #touchLookZone {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            pointer-events: auto;
            touch-action: none;
            /* Importante para prevenir scroll */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
</head>

<body>
    <div id="ui">
        <b>Modo:</b> <span id="mode">Jugador</span><br>
        <div id="pcControlsInfo">
            <b>Controles Jugador:</b> WASD + Mouse<br>
            <b>Controles Auto:</b> Flechas o WASD<br>
            <b>Nitro:</b> Shift (mientras manejas)<br>
            <b>Entrar/Salir Auto:</b> E o Enter<br>
            <b>M√∫sica del Auto:</b> F<br>
            <b>Configuraci√≥n Gr√°fica:</b> L<br>
        </div>
        <span id="status">Cargando modelo...</span><br>
        <div id="coordsDisplay">üìç X: 0.00 | Y: 0.00 | Z: 0.00</div>
        <span id="musicInfo" style="color: #00ff88;"></span>
    </div>
    <div id="crosshair"></div>

    <!-- Controles M√≥biles -->
    <div id="mobileControls">
        <div id="joystickZone"></div>
        <div id="touchLookZone"></div> <!-- Zona derecha para mover c√°mara -->
        <div id="mobileActionBtn">üñêÔ∏è</div>
        <div id="mobileEnterBtn">üö™</div>

        <!-- Controles de Auto (Ocultos en modo jugador) -->
        <div id="mobileCarControls">
            <div id="btnLeft" class="car-btn">‚¨ÖÔ∏è</div>
            <div id="btnRight" class="car-btn">‚û°Ô∏è</div>
            <div id="btnBrake" class="car-btn">üõë</div>
            <div id="btnGas" class="car-btn">‚ö°</div>
            <div id="btnNitro" class="car-btn">üî•</div>
        </div>
    </div>

    <!-- Login Menu -->
    <div id="loginMenu">
        <h2>üöó Chipeo Simulator üåê</h2>
        <p style="color: #aaa; text-align: center;">Ingresa tu nombre para jugar online</p>
        <input type="text" id="playerName" placeholder="Tu nombre" maxlength="20">
        <div style="text-align: center; margin-top: 15px;">
            <button id="joinBtn">üéÆ Unirse al Juego</button>
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #888; text-align: center;">
            üí° ¬°Juega con otros jugadores en tiempo real!
        </div>
    </div>

    <!-- Players Online Panel -->
    <div id="playersPanel">
        <h3>üë• Jugadores Online</h3>
        <div id="playersList"></div>
    </div>

    <!-- Men√∫ de Configuraci√≥n Gr√°fica -->
    <div id="graphicsMenu">
        <h2>‚öôÔ∏è Configuraci√≥n Gr√°fica</h2>
        <div class="quality-option" data-quality="low">
            <h3>üîß Bajo</h3>
            <p>Distancia de renderizado reducida ‚Ä¢ Optimizado para mejor rendimiento</p>
        </div>
        <div class="quality-option selected" data-quality="normal">
            <h3>‚öñÔ∏è Normal</h3>
            <p>Configuraci√≥n est√°ndar ‚Ä¢ Balance entre calidad y rendimiento</p>
        </div>
        <div class="quality-option" data-quality="high">
            <h3>‚ú® Alto</h3>
            <p>Iluminaci√≥n mejorada ‚Ä¢ Sol centrado ‚Ä¢ M√°xima calidad visual</p>
        </div>
        <button id="closeGraphicsBtn">‚úñÔ∏è Cerrar</button>
    </div>

    <!-- Barra de Nitro -->
    <div id="nitroBarContainer">
        <div id="nitroBar"></div>
    </div>

    <!-- Efecto de Velocidad -->
    <div id="speedEffect"></div>

    <div id="musicMenu">
        <h2>üéµ Music Car - Bass Boost Radio üéµ</h2>
        <input type="text" id="musicUrl" placeholder="Pega aqu√≠ el link .mp3 de tu m√∫sica (Discord, Drive, etc.)">
        <div class="volumeControl">
            <label>Volumen M√°ximo: <span id="volumeValue">100</span>%</label>
            <input type="range" id="volumeSlider" min="0" max="100" value="100">
        </div>
        <div class="volumeControl">
            <label>Sensibilidad Bass: <span id="bassValue">50</span>%</label>
            <input type="range" id="bassSensitivity" min="0" max="100" value="50">
        </div>
        <div class="volumeControl" style="display: flex; align-items: center; justify-content: center;">
            <input type="checkbox" id="audio3DCheckbox" style="margin-right: 10px; width: auto;">
            <label for="audio3DCheckbox" style="margin: 0; cursor: pointer;">Activado Audio 3D üéß</label>
        </div>
        <div style="text-align: center;">
            <button id="playBtn">‚ñ∂Ô∏è Reproducir</button>
            <button id="stopBtn">‚èπÔ∏è Detener</button>
            <button id="closeBtn">‚úñÔ∏è Cerrar</button>
        </div>
        <div class="musicStatus">
            <span id="musicStatusText">No hay m√∫sica cargada</span>
        </div>
        <div class="bassIndicator">
            üîä Bass Level: <span id="bassLevel">0</span>%
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #888;">
            üí° Tip: El auto rebota con los bajos de la m√∫sica üöóüí®
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js'; // Importar Draco
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // FIREBASE IMPORTS
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, get, update as dbUpdate, onValue, remove, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        // ... (This content will be generated after I check road coordinates) (Firebase Config)

        // Configuraci√≥n de Draco (Decodificadores s√∫per r√°pidos)
        const dracoLoader = new DRACOLoader();
        // Usamos los decodificadores oficiales de la versi√≥n de Three.js que estamos usando
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
        dracoLoader.preload(); // Pre-argar para que est√© listo cuanto antes

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCw0v9mVUpOO8HYYfHLhyzkgIMfoBljJcQ",
            authDomain: "fortnite-8012b.firebaseapp.com",
            databaseURL: "https://fortnite-8012b-default-rtdb.firebaseio.com",
            projectId: "fortnite-8012b",
            storageBucket: "fortnite-8012b.firebasestorage.app",
            messagingSenderId: "862924450554",
            appId: "1:862924450554:web:b01ab7f85afa7965c2f743",
            measurementId: "G-8Q997GYMM2"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // ========================================
        // üíæ SISTEMA DE CACH√â PERSISTENTE (IndexedDB)
        // ========================================
        const DB_NAME = 'ChipeoSimulatorCache';
        const DB_VERSION = 1; // Revertido como solicitado
        const STORE_NAME = 'models';

        let db = null;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.error);
                    resolve(null); // Fallback: funciona sin cache si falla
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    // console.log("DB Inicializada");
                    resolve(db);
                };
            });
        }

        async function getModelFromDB(url) {
            if (!db) return null;
            return new Promise((resolve) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(url);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => resolve(null);
            });
        }

        async function saveModelToDB(url, buffer) {
            if (!db) return;
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            store.put(buffer, url);
        }

        // Inicializar DB al arrancar
        initDB();

        // Funci√≥n de carga unificada con cach√© (RAM + IndexedDB)
        const ramCache = {}; // Cache en memoria para clones r√°pidos

        async function loadGLTFWithCache(url, onProgress) {
            // 1. Verificar Cache RAM (GLTF parseado)
            if (ramCache[url]) {
                // Si es una promesa, esperar. Si es datos, devolver.
                if (ramCache[url] instanceof Promise) return ramCache[url];
                return Promise.resolve(ramCache[url]);
            }

            // Crear promesa de carga para evitar peticiones duplicadas simult√°neas
            const loadPromise = new Promise(async (resolve, reject) => {
                const loader = new GLTFLoader();
                loader.setDRACOLoader(dracoLoader); // ACTIVAR DRACO PARA ESTE LOADER


                // 2. Verificar IndexedDB (ArrayBuffer)
                try {
                    const cachedBuffer = await getModelFromDB(url);
                    if (cachedBuffer) {
                        console.log(`üì¶ Cargando desde cach√©: ${url.split('/').pop()}`);
                        loader.parse(cachedBuffer, '', (gltf) => {
                            ramCache[url] = gltf; // Guardar en RAM
                            resolve(gltf);
                        }, (err) => {
                            console.warn("Error parsing cached model, redownloading...", err);
                            // Fallback a descarga normal si falla parseo
                            downloadAndCache();
                        });
                        return;
                    }
                } catch (e) {
                    console.warn("DB Cache check failed", e);
                }

                // 3. Descargar si no est√° en cach√©
                function downloadAndCache() {
                    const fileLoader = new THREE.FileLoader();
                    fileLoader.setResponseType('arraybuffer');

                    fileLoader.load(url, (data) => {
                        // Guardar en DB
                        saveModelToDB(url, data);

                        // Parsear
                        loader.parse(data, '', (gltf) => {
                            ramCache[url] = gltf;
                            resolve(gltf);
                        }, reject);

                    }, onProgress, reject);
                }

                downloadAndCache();
            });

            ramCache[url] = loadPromise;
            return loadPromise;
        }


        // Variables de estado multiplayer
        let currentPlayerId = null;
        let currentPlayerName = null;
        let otherPlayers = {};
        let isOnline = false;
        let lastUpdateTime = 0;
        const UPDATE_INTERVAL = 300; // actualizar cada 300ms (reducido para menos lag)

        // ========================================
        // SISTEMA DE AUDIO CON PRIORIDAD POR DISTANCIA
        // Solo reproduce los 5 autos m√°s cercanos al jugador
        // ========================================
        const MAX_CONCURRENT_AUDIOS = 5; // L√≠mite del navegador
        let activeAudioSources = new Set(); // Track de audios activos

        // Para detecci√≥n de cambios
        let lastSentPosition = { x: 0, y: 0, z: 0, rotation: 0, mode: 'player' };
        const MIN_POSITION_CHANGE = 0.5; // m√≠nimo cambio de posici√≥n para enviar update
        const MIN_ROTATION_CHANGE = 0.1; // m√≠nimo cambio de rotaci√≥n para enviar update

        // Sistema de Audio DUAL - cada auto tiene su propio sistema de audio
        let audioContext = null;

        let car1Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioElement: new Audio(),
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };

        let car2Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioElement: new Audio(),
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };

        let car3Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioElement: new Audio(),
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };

        let car4Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioElement: new Audio(),
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };

        let car5Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioElement: new Audio(),
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };

        let car6Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioElement: new Audio(),
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };

        let car7Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioElement: new Audio(),
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };

        let bocina1Audio = {
            analyser: null,
            dataArray: null,
            audioSource: null,
            audioElement: new Audio(),
            maxVolume: 1.0,
            isPlaying: false,
            bassSensitivity: 0.5,
            gainNode: null,
            bounce: 0
        };
        // ========================================
        // üöó CONFIGURACI√ìN DE AUTOS - ¬°EDITA AQU√ç!
        // ========================================
        // Para agregar m√°s autos, solo agrega objetos a este array:
        const carsConfig = [
            {
                id: 'car1',
                name: 'El azul',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/elazul.glb',
                position: { x: 0, y: 1.7, z: -10 },
                rotation: { x: 0, y: -Math.PI / 2, z: 0 }, // -90¬∞ para que mire adelante como en la versi√≥n anterior
                scale: 1.5,
                audio: car1Audio
            },
            {
                id: 'car2',
                name: 'La camiona',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/LaCamiona.glb',
                position: { x: 5, y: 2.5, z: -10 },
                rotation: { x: 0, y: -Math.PI / 2, z: 0 }, // -90¬∞ para que mire adelante
                scale: 2.4,
                audio: car2Audio
            },
            {
                id: 'car3',
                name: 'El neforepi',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/Neforepiop.glb',
                position: { x: 15, y: 1.5, z: -10 },
                rotation: { x: 0, y: 0, z: 0 }, // Ajustado para que mire hacia adelante
                scale: 1.5,
                audio: car3Audio
            },
            {
                id: 'car4',
                name: 'El dorado',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/Eldorado.glb',
                position: { x: 20, y: 3.5, z: -10 },
                rotation: { x: 0, y: -Math.PI / 2, z: 0 }, // Ajustado para que mire hacia adelante
                scale: 2,
                audio: car4Audio
            },
            {
                id: 'car5',
                name: 'El Pebeseta',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/Elazulado.glb',
                position: { x: 25, y: 3.5, z: -10 },
                rotation: { x: 0, y: -Math.PI / 2, z: 0 }, // Ajustado para que mire hacia adelante
                scale: 2,
                audio: car5Audio
            },
            {
                id: 'car6',
                name: 'El azulbug',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/elazulbugnt.glb',
                position: { x: 30, y: 3.5, z: -10 },
                rotation: { x: 0, y: -Math.PI / 2, z: 0 }, // Ajustado para que mire hacia adelante
                scale: 2,
                audio: car6Audio
            },
            {
                id: 'car7',
                name: 'El Elrojo',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/Elrojo.glb',
                position: { x: 35, y: 2.3, z: -10 },
                rotation: { x: 0, y: -Math.PI / 2, z: 0 }, // Ajustado para que mire hacia adelante
                scale: 1.5,
                audio: car7Audio
            }
            // Para agregar m√°s autos, copia y pega este bloque:
            // {
            //     id: 'car3',
            //     name: 'Auto 3',
            //     modelUrl: 'URL_DEL_MODELO.glb',
            //     position: { x: 30, y: 0, z: -10 },
            //     rotation: { x: 0, y: 0, z: 0 },
            //     scale: 2,
            //     audio: car3Audio // Necesitas crear car3Audio arriba
            // }
        ];

        // ========================================
        // üèóÔ∏è CONFIGURACI√ìN DE DECORACIONES (OBJETOS)
        // ========================================
        // Agrega aqu√≠ edificios, sillas, farolas, etc.
        const decorationsConfig = [
            {
                id: 'silla1',
                name: 'Silla Pl√°stica 1',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/Sillaop.glb',
                position: { x: -2.73, y: 0.2, z: 11.97 },
                rotation: { x: 0, y: 0, z: 0 },
                scale: 1.5,
                hasCollision: true,
                silla: true
            },
            {
                id: 'silla2',
                name: 'Edificio de Prueba',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/Sillaop.glb', // Usando link de auto como ejemplo
                position: { x: -2.73, y: 0.3, z: 17.16 },
                rotation: { x: 0, y: 0, z: 0 },
                scale: 1.5,
                hasCollision: true,
                silla: true
            },
            {
                id: 'ejemplo_edificio3',
                name: 'Edificio de Prueba',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/Colmadoop.glb', // Usando link de auto como ejemplo
                position: { x: -6.79, y: 2.5, z: 14.25 },
                rotation: { x: 0, y: 0, z: 0 },
                scale: 8,
                hasCollision: false
            },
            {
                id: 'bocina1',
                name: 'Bocina de Chipeo',
                modelUrl: 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/Bocina.glb',
                position: { x: -3.63, y: 0.5, z: 15.16 },
                rotation: { x: 0, y: 0, z: 0 },
                scale: 2.0,
                hasCollision: true,
                radio: true, // Sistema simplificado: solo falta esta variable
                audio: bocina1Audio
            }
            // {
            //     id: 'silla1',
            //     name: 'Silla',
            //     modelUrl: 'URL_MODELO_SILLA.glb',
            //     position: { x: 10, y: 0, z: 10 },
            //     rotation: { x: 0, y: 0, z: 0 },
            //     scale: 1,
            //     hasCollision: false
            // }
        ];

        // Crear elementos de audio HTML para cada auto (SIN Web Audio API - sin CORS issues)
        carsConfig.forEach(config => {
            const audioElement = document.createElement('audio');
            audioElement.loop = true;
            audioElement.volume = config.audio.maxVolume;
            audioElement.preload = 'auto';
            config.audio.audioElement = audioElement;
            console.log(`üîä Elemento de audio creado para ${config.name}`);
        });

        // Crear elementos de audio HTML para decoraciones con audio (Bocinas)
        decorationsConfig.forEach(config => {
            if (config.audio) {
                const audioElement = document.createElement('audio');
                audioElement.loop = true;
                audioElement.volume = config.audio.maxVolume || 1.0;
                audioElement.preload = 'auto';
                audioElement.crossOrigin = "anonymous"; // Importante para Web Audio API
                config.audio.audioElement = audioElement;
                console.log(`üîä Elemento de audio creado para decoraci√≥n ${config.name}`);
            }
        });

        // Array para almacenar referencias a autos y decoraciones cargadas
        const loadedCars = {};
        const loadedDecorations = {};
        const carMusicState = {};
        const loadedMusicURLs = {}; // Global para evitar conflictos
        const loadingInProgress = {}; // Global para evitar conflictos
        const lastLoadTime = {}; // Global para evitar conflictos

        // Auto activo en el men√∫ de m√∫sica
        let currentAudioTarget = null; // ID del auto ('car1', 'car2', etc)

        // YouTube Player (mantener compatibilidad)
        let youtubePlayer = null;
        let youtubePlayerReady = false;
        let currentMusicType = null; // 'audio' o 'youtube'

        let isPlayerMode = true; // true = caminando, false = en auto
        let isSitting = false;
        let currentSillaId = null;
        // Rol en el auto
        let carRole = null; // 'driver', 'passenger', o null
        let currentCarId = null; // ID del auto en el que est√°s

        // Detecci√≥n de m√≥vil
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // 1. ESCENA Y RENDERER
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 150, 400);

        const renderer = new THREE.WebGLRenderer({
            antialias: !isMobile && window.devicePixelRatio < 2, // Desactivar antialias en m√≥vil
            powerPreference: isMobile ? "default" : "high-performance", // Ahorrar bater√≠a/calor en m√≥vil
            stencil: false,
            depth: true,
            precision: isMobile ? "mediump" : "highp" // Menor precisi√≥n en shaders m√≥viles
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap; // M√°ximo rendimiento por defecto
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.0 : 1.2)); // Capar pixel ratio
        document.body.appendChild(renderer.domElement);

        // 2. C√ÅMARA
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.rotation.order = 'YXZ'; // IMPORTANTE para evitar que la c√°mara se voltee (roll) al rotar
        camera.position.set(0, 2, 5);

        // 3. CONTROLES DE POINTER LOCK
        const controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        let isMusicMenuOpen = false;
        const playerSpeed = 0.15;

        const playerRadius = 0.6; // Aumentado el radio de entrada al veh√≠culo
        const moveForward = { active: false };
        const moveBackward = { active: false };
        const moveLeft = { active: false };
        const moveRight = { active: false };



        if (isMobile) {
            console.log("üì± Dispositivo m√≥vil detectado");
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block'; // Mostrar siempre cruz en m√≥vil
            document.getElementById('pcControlsInfo').style.display = 'none'; // Ocultar controles de PC en m√≥vil

            // --- JOYSTICK (Movimiento) ---
            const joystickManager = nipplejs.create({
                zone: document.getElementById('joystickZone'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'white',
                size: 100
            });

            joystickManager.on('move', function (evt, data) {
                if (data.direction) {
                    moveForward.active = (data.direction.y === 'up');
                    moveBackward.active = (data.direction.y === 'down');
                    moveLeft.active = (data.direction.x === 'left');
                    moveRight.active = (data.direction.x === 'right');
                }
            });

            joystickManager.on('end', function () {
                moveForward.active = false;
                moveBackward.active = false;
                moveLeft.active = false;
                moveRight.active = false;
            });

            // --- BOT√ìN ACCI√ìN (F) ---
            const actionBtn = document.getElementById('mobileActionBtn');
            actionBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                window.dispatchEvent(new KeyboardEvent('keydown', { 'key': 'f' }));
                // Feedback visual
                actionBtn.style.transform = "scale(0.9)";
                setTimeout(() => actionBtn.style.transform = "scale(1)", 100);
            });

            // --- TOUCH LOOK (C√°mara) ---
            const touchLookZone = document.getElementById('touchLookZone');
            let previousTouchX = 0;
            let previousTouchY = 0;
            let lookTouchId = null; // Rastrear el ID del dedo que mueve la c√°mara

            touchLookZone.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Evitar scroll
                const touch = e.changedTouches[0];
                lookTouchId = touch.identifier;
                previousTouchX = touch.pageX;
                previousTouchY = touch.pageY;
            });

            touchLookZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                // Buscar el dedo correcto por ID
                let touch = null;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === lookTouchId) {
                        touch = e.changedTouches[i];
                        break;
                    }
                }

                if (!touch) return; // Si no es el dedo de la c√°mara, ignorar

                const touchX = touch.pageX;
                const touchY = touch.pageY;
                const deltaX = touchX - previousTouchX;
                const deltaY = touchY - previousTouchY;
                const sensitivity = 0.004;

                // Rotaci√≥n T√°ctil (Yaw y Pitch)
                controls.getObject().rotation.y -= deltaX * sensitivity;

                camera.rotation.x -= deltaY * sensitivity;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                // Reset Roll
                camera.rotation.z = 0;
                controls.getObject().rotation.z = 0;

                previousTouchX = touchX;
                previousTouchY = touchY;
            });

            touchLookZone.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === lookTouchId) {
                        lookTouchId = null;
                        break;
                    }
                }
            });

            // --- BOT√ìN ENTRAR/SALIR (PUERTA) ---
            const enterBtn = document.getElementById('mobileEnterBtn');
            enterBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                window.dispatchEvent(new KeyboardEvent('keydown', { 'key': 'e' }));
                // Feedback visual
                enterBtn.style.transform = "scale(0.9)";
                setTimeout(() => enterBtn.style.transform = "scale(1)", 100);
            });

            // --- CONTROLES DE AUTO (BOTONES) ---
            const btnLeft = document.getElementById('btnLeft');
            const btnRight = document.getElementById('btnRight');
            const btnGas = document.getElementById('btnGas');
            const btnBrake = document.getElementById('btnBrake');
            const btnNitro = document.getElementById('btnNitro');

            const addTouchControl = (btn, actionObj, isNitro = false) => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (isNitro) {
                        window.dispatchEvent(new KeyboardEvent('keydown', { 'key': 'Shift' }));
                    } else {
                        actionObj.active = true;
                    }
                    btn.style.opacity = "0.8";
                    btn.style.transform = "scale(0.95)";
                });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (isNitro) {
                        window.dispatchEvent(new KeyboardEvent('keyup', { 'key': 'Shift' }));
                    } else {
                        actionObj.active = false;
                    }
                    btn.style.opacity = "";
                    btn.style.transform = "";
                });
            };

            addTouchControl(btnLeft, moveLeft);
            addTouchControl(btnRight, moveRight);
            addTouchControl(btnGas, moveForward);
            addTouchControl(btnBrake, moveBackward);
            addTouchControl(btnNitro, null, true);
        }

        document.addEventListener('click', () => {
            if (!isMobile && isPlayerMode && !controls.isLocked && !isMusicMenuOpen) {
                controls.lock();
            }
        });

        controls.addEventListener('lock', () => {
            document.getElementById('crosshair').style.display = 'block';
        });
        controls.addEventListener('unlock', () => {
            document.getElementById('crosshair').style.display = 'none';
        });

        // 4. LUCES
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(50, 50, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 200; // Reducir distancia de sombras
        sun.shadow.bias = -0.0001;
        sun.shadow.radius = 4; // Suavizar bordes de sombras
        scene.add(sun);

        // Variables de configuraci√≥n Gr√°fica (Globales)
        let LOD_DISTANCE_NEAR = 30;
        let LOD_DISTANCE_MID = 60;
        let LOD_DISTANCE_FAR = 100;
        let VISIBILITY_DISTANCE = 150;
        let fillLights = [];
        let currentGraphicsQuality = 'normal';

        // Funci√≥n para aplicar calidad gr√°fica
        function applyGraphicsQuality(quality) {
            currentGraphicsQuality = quality;

            // Remover luces de relleno si existen
            fillLights.forEach(light => {
                scene.remove(light);
            });
            fillLights = [];

            if (quality === 'low') {
                // BAJO: Reducir distancias de renderizado considerablemente
                LOD_DISTANCE_NEAR = 10;
                LOD_DISTANCE_MID = 20;
                LOD_DISTANCE_FAR = 30;
                VISIBILITY_DISTANCE = 50; // Reducido de 70

                // DESACTIVAR SOMBRAS TOTALMENTE (Renderer)
                renderer.shadowMap.enabled = false;
                renderer.setPixelRatio(1); // Forzar resoluci√≥n base

                sun.castShadow = false;
                ambientLight.intensity = 1.0;

                sun.position.set(50, 50, 50);
                sun.intensity = 0.5;

            } else if (quality === 'normal') {
                // NORMAL: Configuraci√≥n est√°ndar
                LOD_DISTANCE_NEAR = 30;
                LOD_DISTANCE_MID = 60;
                LOD_DISTANCE_FAR = 100;
                VISIBILITY_DISTANCE = 150;

                // ACTIVAR SOMBRAS
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.BasicShadowMap;
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2));

                sun.castShadow = true;
                sun.shadow.mapSize.width = 1024; // Calidad media de sombras
                sun.shadow.mapSize.height = 1024;
                sun.shadow.camera.far = 150;
                sun.shadow.bias = -0.0001;
                ambientLight.intensity = 0.8;

                sun.position.set(50, 50, 50);
                sun.intensity = 1;

            } else if (quality === 'high') {
                // ALTO: Iluminaci√≥n mejorada con sol centrado
                LOD_DISTANCE_NEAR = 50; // Mejorado
                LOD_DISTANCE_MID = 100;
                LOD_DISTANCE_FAR = 200;
                VISIBILITY_DISTANCE = 300;

                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Mejores sombras
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));

                // M√°xima calidad de sombras - ASEGURAR QUE EST√âN ACTIVAS
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                sun.shadow.camera.far = 200;
                sun.shadow.camera.left = -100;
                sun.shadow.camera.right = 100;
                sun.shadow.camera.top = 100;
                sun.shadow.camera.bottom = -100;
                ambientLight.intensity = 1.2;

                // Sol centrado arriba
                sun.position.set(0, 100, 0);
                sun.intensity = 0.8;

                // Agregar luces de relleno
                const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.3);
                fillLight1.position.set(0, 50, 50);
                scene.add(fillLight1);
                fillLights.push(fillLight1);

                const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.2);
                fillLight2.position.set(0, 30, -50);
                scene.add(fillLight2);
                fillLights.push(fillLight2);

                const fillLight3 = new THREE.DirectionalLight(0xffffff, 0.15);
                fillLight3.position.set(50, 40, 0);
                scene.add(fillLight3);
                fillLights.push(fillLight3);

                const fillLight4 = new THREE.DirectionalLight(0xffffff, 0.15);
                fillLight4.position.set(-50, 40, 0);
                scene.add(fillLight4);
                fillLights.push(fillLight4);
            }

            // Actualizar sombras
            sun.shadow.camera.updateProjectionMatrix();

            // Guardar en LocalStorage
            localStorage.setItem('graphicsQuality', quality);

            // Actualizar selector visual en el men√∫
            document.querySelectorAll('.quality-option').forEach(opt => {
                if (opt.dataset.quality === quality) {
                    opt.classList.add('selected');
                } else {
                    opt.classList.remove('selected');
                }
            });
        }

        // Cargar calidad guardada al iniciar
        const savedQuality = localStorage.getItem('graphicsQuality');
        if (savedQuality) {
            applyGraphicsQuality(savedQuality);
        } else {
            // Default si no hay nada guardado
            if (isMobile) {
                console.log("üì± M√≥vil detectado: Configurando gr√°ficos en BAJO por defecto.");
                applyGraphicsQuality('low');
            } else {
                applyGraphicsQuality('normal');
            }
        }

        // Event listeners para el men√∫ de configuraci√≥n gr√°fica
        document.querySelectorAll('.quality-option').forEach(option => {
            option.addEventListener('click', () => {
                const quality = option.dataset.quality;
                applyGraphicsQuality(quality);
            });
        });

        const closeGraphicsHandler = (e) => {
            if (e) e.preventDefault();
            document.getElementById('graphicsMenu').style.display = 'none';
            isMusicMenuOpen = false;
        };
        document.getElementById('closeGraphicsBtn').addEventListener('click', closeGraphicsHandler);
        document.getElementById('closeGraphicsBtn').addEventListener('touchstart', closeGraphicsHandler);

        // 5. PISO
        const floorGeo = new THREE.PlaneGeometry(1000, 1000);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x5cb85c,
            roughness: 0.8,
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // CARRETERA
        const roadGeo = new THREE.PlaneGeometry(20, 1000);
        const roadMat = new THREE.MeshStandardMaterial({
            color: 0x3d3d3d,
            roughness: 0.9,
        });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0.01;
        road.receiveShadow = true;
        scene.add(road);

        // L√≠neas amarillas
        const lineGeo = new THREE.PlaneGeometry(0.5, 10);
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffdd00 });

        // ... (L√≠neas amarillas)
        for (let i = -50; i < 50; i++) {
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.rotation.x = -Math.PI / 2;
            line.position.set(0, 0.02, i * 20);
            scene.add(line);
        }

        // --- POSTES DE LUZ (GEOMETR√çA COMPARTIDA) ---
        const posteGeo = new THREE.CylinderGeometry(0.15, 0.3, 10, 4);
        const crucetaGeo = new THREE.BoxGeometry(2.5, 0.1, 0.1);
        const aislanteGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.2);

        // Curva del brazo (Est√°tica)
        const armCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 7.5, 0),
            new THREE.Vector3(1, 7.8, 0),
            new THREE.Vector3(2.5, 7.5, 0)
        ]);
        const brazoGeo = new THREE.TubeGeometry(armCurve, 10, 0.06, 4, false); // Reducido segmentos para optimizar

        const cabezaGeo = new THREE.SphereGeometry(0.25, 8, 8); // Low poly
        const bombillaGeo = new THREE.SphereGeometry(0.15, 8, 8); // Low poly

        // Materiales compartidos
        const concreteMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const metalMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });
        const aislanteMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
        const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffffcc }); // Color fijo

        function crearPosteOptimizado(xPos, zPos, rotationY = 0) {
            const group = new THREE.Group();

            // Cuerpo
            const p = new THREE.Mesh(posteGeo, concreteMat);
            p.position.y = 5;
            p.rotation.y = Math.PI / 4;
            p.castShadow = true;
            p.receiveShadow = true;
            group.add(p);

            // Crucetas
            [9.2, 8.2].forEach(y => {
                const arm = new THREE.Mesh(crucetaGeo, metalMat);
                arm.position.y = y;
                group.add(arm);
                [-1, 0, 1].forEach(x => {
                    const ins = new THREE.Mesh(aislanteGeo, aislanteMat);
                    ins.position.set(x, y + 0.15, 0);
                    group.add(ins);
                });
            });

            // Brazo l√°mpara
            const brazo = new THREE.Mesh(brazoGeo, metalMat);
            group.add(brazo);

            // Cabeza Cobra
            const head = new THREE.Mesh(cabezaGeo, concreteMat);
            head.scale.set(1.5, 0.4, 0.8);
            head.position.set(2.5, 7.45, 0);
            group.add(head);

            // Bombilla visual
            const bulb = new THREE.Mesh(bombillaGeo, bulbMat);
            bulb.scale.set(1.2, 0.3, 0.8);
            bulb.position.set(2.5, 7.35, 0);
            group.add(bulb);

            // 1. Aplicar Rotaci√≥n
            group.rotation.y = rotationY;
            group.position.set(xPos, 0, zPos);
            scene.add(group);

            // 2. Calcular Puntos Rotados (para cables)
            const rotatePoint = (x, y, z) => {
                const vec = new THREE.Vector3(x, y, z);
                vec.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationY);
                vec.add(new THREE.Vector3(xPos, 0, zPos));
                return vec;
            };

            const offsetsX = [1, 0, -1];
            const upperPoints = offsetsX.map(x => rotatePoint(x, 9.45, 0));
            const lowerPoints = offsetsX.map(x => rotatePoint(x, 8.45, 0));

            return upperPoints.concat(lowerPoints);
        }

        // CABLES
        function conectarCables(pA, pB) {
            // Material de l√≠nea simple (m√°s barato que tubos)
            const cableMat = new THREE.LineBasicMaterial({ color: 0x000000 });

            pA.forEach((start, i) => {
                const end = pB[i];
                const mid = new THREE.Vector3((start.x + end.x) / 2, (start.y + end.y) / 2 - 0.5, (start.z + end.z) / 2);
                const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
                const points = curve.getPoints(8); // Pocos puntos
                const geom = new THREE.BufferGeometry().setFromPoints(points);
                scene.add(new THREE.Line(geom, cableMat));
            });
        }

        // GENERAR POSTES A LO LARGO DE LA CARRETERA
        const postesIzquierda = [];
        const postesDerecha = []; // Si quisieras poner en ambos lados

        // Lado Izquierdo (X = -12)
        let ultimoPoste = null;
        for (let z = -200; z <= 200; z += 60) {
            const pts = crearPosteOptimizado(-12, z);
            if (ultimoPoste) {
                conectarCables(ultimoPoste, pts);
            }
            ultimoPoste = pts;
        }

        // Lado Derecho (X = 12) - Opcional, lo activamos tambi√©n
        let ultimoPosteDer = null;
        for (let z = -200; z <= 200; z += 60) {
            const pts = crearPosteOptimizado(12, z, Math.PI);
            // Rotar 180 grados? No, la geometr√≠a mira a +X. 
            // Si est√° en X=12, deber√≠a mirar a -X (hacia la calle).
            // La funci√≥n crearPosteOptimizado no rota el grupo.
            // Para el lado derecho, necesitamos rotarlo. 
            // Modificaremos la funci√≥n para aceptar rotaci√≥n? O rotamos el grupo despu√©s.
            // Pero los cables dependen de la posici√≥n global world.
            // Simplificaci√≥n: Solo lado izquierdo por ahora para no complicar cables.

            if (ultimoPosteDer) {
                conectarCables(ultimoPosteDer, pts);
            }
            ultimoPosteDer = pts;
        }

        // --- LETRERO COLMADO (KA SUPPLY) ---
        function createSignTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Fondo Negro
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Franja Rosa Inferior
            ctx.fillStyle = '#d63384';
            ctx.beginPath();
            ctx.moveTo(0, 180);
            ctx.bezierCurveTo(128, 160, 384, 160, 512, 180);
            ctx.lineTo(512, 256);
            ctx.lineTo(0, 256);
            ctx.fill();

            // Texto Principal
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.font = 'bold 86px Serif';
            ctx.fillText('Colmado', canvas.width / 2, 80);

            ctx.font = 'bold 43px Sans-serif';
            ctx.fillText('EL Patron', canvas.width / 2, 130);

            ctx.font = '23px Sans-serif';
            ctx.fillText('Delivery grati', canvas.width / 2, 155);

            // Tel√©fono en la parte rosa
            ctx.fillStyle = 'white';
            ctx.font = 'bold 22px Sans-serif';
            ctx.fillText('829-2pal de frito una hala y un mulito', canvas.width / 2, 230);

            return new THREE.CanvasTexture(canvas);
        }

        function crearLetrero(x, y, z) {
            const group = new THREE.Group();

            // Textura
            const signTexture = createSignTexture();

            // 1. El Poste
            const poleGeometry = new THREE.BoxGeometry(0.3, 12, 0.3);
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x707070 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 6; // Para que la base est√© en 0
            pole.castShadow = true;
            pole.receiveShadow = true;
            group.add(pole);

            // 2. La Caja del Letrero
            const boxGeometry = new THREE.BoxGeometry(5, 2.5, 0.6);

            // Materiales
            const boxBaseMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const boxFaceMat = new THREE.MeshStandardMaterial({ map: signTexture });
            const boxMaterials = [
                boxBaseMat, // Right
                boxBaseMat, // Left
                boxBaseMat, // Top
                boxBaseMat, // Bottom
                boxFaceMat, // Front (+Z)
                boxFaceMat, // Back (-Z)
            ];

            const signBox = new THREE.Mesh(boxGeometry, boxMaterials);
            signBox.position.set(2.4, 10, 0); // Altura ajustada relativa al poste
            signBox.castShadow = true;
            group.add(signBox);

            // 3. Sujetadores
            const bracketGeo = new THREE.BoxGeometry(0.5, 0.1, 0.1);
            const bracket1 = new THREE.Mesh(bracketGeo, poleMaterial);
            bracket1.position.set(0.3, 10.8, 0);
            group.add(bracket1);

            const bracket2 = new THREE.Mesh(bracketGeo, poleMaterial);
            bracket2.position.set(0.3, 9.2, 0);
            group.add(bracket2);

            // Posicionar Grupo
            group.position.set(x, y, z);
            group.rotation.y = 0; // Mirar al frente (eje Z)

            scene.add(group);
        }

        // Crear letrero cerca del colmado (X=-6.79, Z=14.25)
        // Lo ponemos al otro lado (derecha del edificio, ~ -3) y m√°s adelante (Z ~ 18)
        crearLetrero(-5, 0, 20);

        // VEGETACI√ìN OPTIMIZADA (INSTANCED MESH)
        // Esto permite dibujar miles de √°rboles/flores con un solo dibujo (Draw Call)
        const treeCount = 60;
        const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6b4423, roughness: 0.9 });
        const foliageGeo = new THREE.SphereGeometry(2, 8, 8);
        const foliageMat = new THREE.MeshStandardMaterial({ color: 0x3a7d3a, roughness: 0.8 });

        const instancedTrunks = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
        const instancedFoliage = new THREE.InstancedMesh(foliageGeo, foliageMat, treeCount);
        instancedTrunks.castShadow = true;
        instancedTrunks.receiveShadow = true;
        instancedFoliage.castShadow = true;
        instancedFoliage.receiveShadow = true;

        const dummy = new THREE.Object3D();
        let placedTrees = 0;
        while (placedTrees < treeCount) {
            const x = (Math.random() - 0.5) * 600;
            const z = (Math.random() - 0.5) * 1000;
            if (Math.abs(x) < 25) continue; // M√°s margen para la carretera

            dummy.position.set(x, 1.5, z);
            dummy.updateMatrix();
            instancedTrunks.setMatrixAt(placedTrees, dummy.matrix);

            dummy.position.set(x, 4, z);
            dummy.updateMatrix();
            instancedFoliage.setMatrixAt(placedTrees, dummy.matrix);
            placedTrees++;
        }
        scene.add(instancedTrunks, instancedFoliage);

        // Flores Instanciadas
        const flowerCount = 100;
        const flowerGeo = new THREE.SphereGeometry(0.2, 6, 6);
        const flowerMat = new THREE.MeshStandardMaterial({ color: 0xff5252, roughness: 0.6 });
        const instancedFlowers = new THREE.InstancedMesh(flowerGeo, flowerMat, flowerCount);
        instancedFlowers.castShadow = true;

        let placedFlowers = 0;
        while (placedFlowers < flowerCount) {
            const x = (Math.random() - 0.5) * 500;
            const z = (Math.random() - 0.5) * 1000;
            if (Math.abs(x) < 18) continue; // Margen para la calle

            dummy.position.set(x, 0.2, z);
            dummy.updateMatrix();
            instancedFlowers.setMatrixAt(placedFlowers, dummy.matrix);

            // Color aleatorio para cada flor
            const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
            instancedFlowers.setColorAt(placedFlowers, color);
            placedFlowers++;
        }
        scene.add(instancedFlowers);

        // --- BLOQUES DE HORMIG√ìN REALISTAS ---
        function createConcreteTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Base
            ctx.fillStyle = '#949494';
            ctx.fillRect(0, 0, 512, 512);

            // Manchas
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
                ctx.beginPath();
                ctx.arc(Math.random() * 512, Math.random() * 512, Math.random() * 100, 0, Math.PI * 2);
                ctx.fill();
            }

            // Grano
            for (let i = 0; i < 40000; i++) {
                const gray = Math.random() * 60 + 80;
                ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                const size = Math.random() * 1.5;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, size, size);
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        const blockConcreteMat = new THREE.MeshStandardMaterial({
            map: createConcreteTexture(),
            roughness: 0.9,
            metalness: 0.05
        });

        // Geometr√≠a Compartida
        const blockShape = new THREE.Shape();
        const bWidth = 4, bDepth = 2; // Dimensiones originales del usuario
        blockShape.moveTo(-bWidth / 2, -bDepth / 2);
        blockShape.lineTo(bWidth / 2, -bDepth / 2);
        blockShape.lineTo(bWidth / 2, bDepth / 2);
        blockShape.lineTo(-bWidth / 2, bDepth / 2);
        blockShape.lineTo(-bWidth / 2, -bDepth / 2);

        function createRoundedRectHole(w, h, r, xOffset) {
            const hole = new THREE.Path();
            hole.moveTo(xOffset + w / 2, -h / 2 + r);
            hole.absarc(xOffset + w / 2 - r, -h / 2 + r, r, 0, Math.PI * 1.5, true);
            hole.absarc(xOffset - w / 2 + r, -h / 2 + r, r, Math.PI * 1.5, Math.PI, true);
            hole.absarc(xOffset - w / 2 + r, h / 2 - r, r, Math.PI, Math.PI * 0.5, true);
            hole.absarc(xOffset + w / 2 - r, h / 2 - r, r, Math.PI * 0.5, 0, true);
            return hole;
        }
        blockShape.holes.push(createRoundedRectHole(1.4, 1.4, 0.3, -1));
        blockShape.holes.push(createRoundedRectHole(1.4, 1.4, 0.3, 1));

        const blockGeometry = new THREE.ExtrudeGeometry(blockShape, {
            steps: 1,
            depth: 2, // Altura extrusion
            bevelEnabled: true,
            bevelThickness: 0.05,
            bevelSize: 0.05,
            bevelSegments: 3
        });
        blockGeometry.center(); // Centrar para facilitar posicionamiento

        function crearBloque(x, y, z, rotY = 0) {
            const block = new THREE.Mesh(blockGeometry, blockConcreteMat);
            block.position.set(x, y, z);
            block.rotation.x = -Math.PI / 2; // Acostado
            block.rotation.z = rotY; // Rotaci√≥n en el suelo (al estar acostado, eje Z es Y visual)

            // Escalar para que tenga sentido en la escena (4x2x2 es muy grande, reducimos a 0.2 -> 80cm)
            block.scale.set(0.4, 0.4, 0.4);

            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
        }

        // Poner bloques de ejemplo (Escala 0.4)
        crearBloque(-7, 0.4, 25, Math.PI / 4);
        crearBloque(-3, 0.4, 22, 0);
        crearBloque(-7, 1.2, 25, -Math.PI / 6); // Apilado

        // 3 Bloques extra
        crearBloque(-5, 0.4, 24, Math.PI / 3);
        crearBloque(-5, 1.2, 24, 0); // Apilado
        crearBloque(-1, 0.4, 23, -Math.PI / 2);

        // ========================================
        // üöó CARGA DIN√ÅMICA DE AUTOS
        // ========================================
        // Este sistema carga autom√°ticamente todos los autos del array carsConfig

        // Variables compatibles con c√≥digo legacy
        let car = null;
        let carContainer = null;
        let carCollisionBox = null;
        let carBaseY = 1.5;

        let car2 = null;
        let car2Container = null;
        let car2CollisionBox = null;
        let car2BaseY = 1.5;
        let car2Bounce = 0;

        // Variable para controlar qu√© auto est√° activo (el que est√°s manejando)
        let activeCarContainer = null;
        let activeCarCollisionBox = null;
        let activeCarBaseY = 1.5;

        // Funci√≥n para optimizar texturas y materiales para m√≥vil
        function optimizeModel(model) {
            model.traverse(node => {
                if (node.isMesh) {
                    // Desactivar frustum culling si causa parpadeos, o mantenerlo true para rendimiento
                    node.frustumCulled = true;

                    // Optimizar Materiales
                    if (node.material) {
                        const materials = Array.isArray(node.material) ? node.material : [node.material];

                        materials.forEach(mat => {
                            // Reducir calidad de shaders en m√≥vil
                            if (isMobile) {
                                mat.dithering = false; // Ahorra GPU
                                if (mat.envMapIntensity) mat.envMapIntensity = 0.5; // Menos reflejos
                            }

                            // Optimizar Texturas
                            for (const key of ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 'emissiveMap']) {
                                if (mat[key]) {
                                    // Anisotrop√≠a baja
                                    mat[key].anisotropy = 1;
                                    // Generar mipmaps solo si es necesario (generalmente s√≠ para evitar ruido, pero consume memoria)
                                    // Si estamos cortos de memoria, podr√≠amos desactivar o reducir resoluci√≥n

                                    // Liberar imagen de origen de la CPU una vez subida a GPU
                                    if (mat[key].source && mat[key].source.data) {
                                        // mat[key].source.data.close && mat[key].source.data.close(); // Para ImageBitmap
                                    }
                                }
                            }
                        });
                    }
                }
            });
        }

        // Funci√≥n para cargar un auto desde configuraci√≥n
        function loadCarFromConfig(config) {
            return new Promise((resolve, reject) => {
                console.log(`üöó Cargando ${config.name} (${config.id})...`);

                const container = new THREE.Group();
                scene.add(container);

                loadGLTFWithCache(config.modelUrl, (xhr) => {
                    if (xhr.lengthComputable) {
                        const progress = (xhr.loaded / xhr.total * 100).toFixed(2);
                        console.log(`${config.name} cargando: ${progress}%`);
                    }
                }).then((cachedGltf) => {
                    // CLONAR LA ESCENA para tener una instancia independiente
                    const model = cachedGltf.scene.clone();

                    // OPTIMIZAR MODELO (TEXTURAS/MATERIALES)
                    optimizeModel(model);

                    // Centrar modelo
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3()).length();
                    const center = box.getCenter(new THREE.Vector3());

                    model.position.x = -center.x;
                    model.position.z = -center.z;
                    model.position.y = -box.min.y;

                    // Aplicar rotaci√≥n de configuraci√≥n
                    model.rotation.x = config.rotation.x;
                    model.rotation.y = config.rotation.y;
                    model.rotation.z = config.rotation.z;

                    // Escalar modelo
                    const scaleFactor = (8 / size) * config.scale;
                    model.scale.set(scaleFactor, scaleFactor, scaleFactor);

                    // Habilitar sombras y configurar LOD
                    const meshes = [];
                    model.traverse(n => {
                        if (n.isMesh) {
                            n.castShadow = true;
                            n.receiveShadow = true;
                            n.frustumCulled = true; // Habilitar frustum culling por mesh
                            meshes.push(n);
                        }
                    });

                    container.add(model);
                    container.position.set(config.position.x, config.position.y || 1.5, config.position.z);

                    // Guardar referencia a meshes para LOD
                    container.userData.meshes = meshes;
                    container.userData.originalMaterials = meshes.map(m => m.material);
                    container.userData.lastLODUpdate = 0;

                    // Calcular collision box
                    const carBox = new THREE.Box3().setFromObject(container);
                    const carSize = carBox.getSize(new THREE.Vector3());
                    const collisionBox = {
                        width: carSize.x * 0.8,
                        length: carSize.z * 0.8,
                        height: carSize.y
                    };

                    // Guardar en loadedCars
                    loadedCars[config.id] = {
                        id: config.id,
                        name: config.name,
                        model: model,
                        container: container,
                        collisionBox: collisionBox,
                        baseY: config.position.y || 1.5,
                        bounce: 0,
                        audio: config.audio,
                        frustumCulled: true // Habilitar frustum culling
                    };

                    // Compatibilidad con c√≥digo legacy
                    if (config.id === 'car1') {
                        car = model;
                        carContainer = container;
                        carCollisionBox = collisionBox;
                        carBaseY = config.position.y || 1.5;
                    } else if (config.id === 'car2') {
                        car2 = model;
                        car2Container = container;
                        car2CollisionBox = collisionBox;
                        car2BaseY = config.position.y || 1.5;
                    }

                    console.log(`‚úÖ ${config.name} cargado!`);
                    resolve(loadedCars[config.id]);
                }).catch((error) => {
                    console.error(`‚ùå Error cargando ${config.name}:`, error);
                    reject(error);
                });
            });
        }

        // ===== SISTEMA DE CACHE DE MODELOS =====
        // Esto evita que el mismo link se descargue varias veces si se usa en distintos objetos
        const modelCache = {};

        // Funci√≥n para cargar decoraciones (OPTIMIZADA CON CACHE Y CLONACI√ìN)
        function loadDecorationFromConfig(config) {
            return new Promise((resolve, reject) => {
                const container = new THREE.Group();
                scene.add(container);

                const modelUrl = config.modelUrl;

                // USAR SISTEMA PERSISTENTE (IndexedDB + RAM)
                loadGLTFWithCache(modelUrl).then((cachedGltf) => {
                    const gltf = cachedGltf; // Alias para compatibilidad con c√≥digo existente
                    const model = gltf.scene.clone(); // CLONAR: Muy r√°pido y ligero

                    // OPTIMIZAR DECORACIONES
                    optimizeModel(model);

                    // Configurar posici√≥n base dentro del contenedor para centrado
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    model.position.x = -center.x;
                    model.position.z = -center.z;
                    model.position.y = -box.min.y;

                    // Aplicar transformaciones individuales
                    model.rotation.set(config.rotation.x || 0, config.rotation.y || 0, config.rotation.z || 0);
                    model.scale.set(config.scale, config.scale, config.scale);

                    // Sombras y Optimizaci√≥n (individual para cada clon)
                    const meshes = [];
                    model.traverse(n => {
                        if (n.isMesh) {
                            n.castShadow = true;
                            n.receiveShadow = true;
                            n.frustumCulled = true;
                            meshes.push(n);
                        }
                    });

                    container.add(model);
                    container.position.set(config.position.x, config.position.y || 0, config.position.z);

                    // Guardar referencia para colisiones y LOD
                    const finalBox = new THREE.Box3().setFromObject(container);
                    const size = finalBox.getSize(new THREE.Vector3());

                    loadedDecorations[config.id] = {
                        id: config.id,
                        name: config.name, // Faltaba esto
                        container: container,
                        meshes: meshes,
                        originalMaterials: meshes.map(m => m.material),
                        hasCollision: config.hasCollision,
                        radio: config.radio,
                        silla: config.silla,
                        baseY: config.position.y || 0,
                        audio: config.audio ? config.audio : (config.radio ? {
                            analyser: null,
                            dataArray: null,
                            audioSource: null,
                            audioElement: new Audio(),
                            maxVolume: 1.0,
                            isPlaying: false,
                            bassSensitivity: 0.8,
                            bounce: 0,
                            _lastFactor: 1
                        } : null),
                        collisionBox: {
                            width: (size.x || 1) * 0.9,
                            length: (size.z || 1) * 0.9
                        }
                    };

                    // Si ya hay m√∫sica para esta bocina en el estado de Firebase, aplicarla
                    if (carMusicState[config.id]) {
                        const m = carMusicState[config.id];
                        const audio = loadedDecorations[config.id].audio;
                        audio.maxVolume = m.volume !== undefined ? m.volume : 1.0;
                        audio.bassSensitivity = m.bassSensitivity !== undefined ? m.bassSensitivity : 0.8;
                        // Si hay URL, cargarla
                        if (m.url && !loadingInProgress[config.id]) {
                            loadAudioFromURL(m.url, config.id).then(() => playAudio(config.id));
                        }
                    }

                    resolve();
                }).catch(reject);
            });
        }

        // Iniciar carga de todo
        async function loadEverything() {
            try {
                // Cargar autos
                await Promise.all(carsConfig.map(config => loadCarFromConfig(config)));
                // Cargar decoraciones
                await Promise.all(decorationsConfig.map(config => loadDecorationFromConfig(config)));

                document.getElementById('status').innerText = "¬°Todo cargado! Presiona F para m√∫sica";
            } catch (error) {
                console.error('Error cargando elementos:', error);
                document.getElementById('status').innerText = "Error al cargar elementos";
            }
        }

        loadEverything();

        // ===== SISTEMA MULTIPLAYER =====

        // Login del jugador
        function joinGame() {
            const nameInput = document.getElementById('playerName');
            const playerName = nameInput.value.trim();

            if (!playerName) {
                alert('Por favor ingresa tu nombre');
                return;
            }

            currentPlayerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            currentPlayerName = playerName;
            isOnline = true;

            // Crear referencia del jugador en Firebase bajo carGame
            const playerRef = ref(database, `carGame/players/${currentPlayerId}`);

            // Configurar datos iniciales del jugador
            set(playerRef, {
                name: currentPlayerName,
                x: 0,
                y: 1.7,
                z: 5,
                rotation: 0,
                mode: 'player', // 'player' or 'car'
                timestamp: Date.now()
            });

            // Configurar desconexi√≥n autom√°tica
            onDisconnect(playerRef).remove();

            // Tambi√©n liberar el auto si lo ten√≠a ocupado al desconectarse
            const carOccupiedRef = ref(database, 'carGame/carOccupied');
            get(carOccupiedRef).then(snapshot => {
                if (snapshot.exists() && snapshot.val() === currentPlayerId) {
                    onDisconnect(carOccupiedRef).remove();
                }
            });

            // Ocultar menu de login y mostrar panel de jugadores
            document.getElementById('loginMenu').style.display = 'none';
            document.getElementById('playersPanel').style.display = 'block';

            // Escuchar cambios en otros jugadores
            setupPlayerListeners();

            console.log('Conectado como:', currentPlayerName);
        }

        // Configurar listeners para otros jugadores
        let playerListenersSetup = false;
        function setupPlayerListeners() {
            if (playerListenersSetup) return;
            playerListenersSetup = true;

            const playersRef = ref(database, 'carGame/players');

            onValue(playersRef, (snapshot) => {
                const players = snapshot.val();

                if (!players) {
                    updatePlayersList({});
                    return;
                }

                // Actualizar lista de jugadores
                updatePlayersList(players);

                // Actualizar modelos 3D de otros jugadores
                Object.keys(players).forEach(playerId => {
                    if (playerId !== currentPlayerId) {
                        const playerData = players[playerId];

                        // Detecci√≥n de FANTASMAS: Si el jugador no se ha actualizado en 5 minutos, eliminarlo
                        const now = Date.now();
                        const lastSeen = playerData.timestamp || 0;
                        if (now - lastSeen > 300000) {
                            console.log(`üëª Jugador fantasma detectado: ${playerData.name}, eliminando...`);
                            removeOtherPlayer(playerId);
                            // Intentar limpiar de la base de datos tambi√©n para que otros no lo carguen
                            remove(ref(database, `carGame/players/${playerId}`));
                            return;
                        }

                        updateOtherPlayer(playerId, playerData);
                    }
                });

                // Eliminar jugadores que ya no est√°n
                Object.keys(otherPlayers).forEach(playerId => {
                    if (!players[playerId]) {
                        removeOtherPlayer(playerId);
                    }
                });
            });

            // Sistema de tracking global (usando variables declaradas arriba)

            // Crear listeners din√°micos para TODOS los autos
            carsConfig.forEach(config => {
                const carMusicRef = ref(database, `carGame/${config.id}Music`);
                onValue(carMusicRef, async (snapshot) => {
                    const musicData = snapshot.val();

                    if (!musicData) {
                        // Limpiar tracking si no hay m√∫sica
                        delete loadedMusicURLs[config.id];
                        delete loadingInProgress[config.id];
                        delete lastLoadTime[config.id];
                        delete carMusicState[config.id];

                        // Detener y liberar recursos localmente
                        stopAudioLocally(config.id);

                        // Actualizar UI si estamos viendo este auto
                        if (currentAudioTarget === config.id) {
                            musicStatusText.textContent = '‚è∏Ô∏è M√∫sica detenida';
                            musicInfo.textContent = '';
                            bassLevelSpan.textContent = '0';
                        }

                        return;
                    }

                    // 1. Guardar estado de m√∫sica por auto siempre
                    carMusicState[config.id] = musicData;

                    // 2. Resolver objeto de audio y aplicar ajustes
                    const audioObj = resolveAudioObject(config.id);
                    if (audioObj) {
                        audioObj.maxVolume = musicData.volume !== undefined ? musicData.volume : 1.0;
                        audioObj.bassSensitivity = musicData.bassSensitivity !== undefined ? musicData.bassSensitivity : 0.5;

                        if (audioObj.audioElement && audioObj.isPlaying) {
                            if (audioObj.audioElement.paused && loadedMusicURLs[config.id] === musicData.url) {
                                playAudio(config.id);
                            }
                        }
                    }

                    // 3. Si YO puse esta m√∫sica, NO recargar el link
                    if (musicData.playerId === currentPlayerId) {
                        loadedMusicURLs[config.id] = musicData.url;
                        return;
                    }

                    // 4. Si ya est√° carg√°ndose esta misma bocina/auto, ignorar este evento
                    if (loadingInProgress[config.id]) return;

                    // 5. Si la URL es la misma, no recargar
                    if (loadedMusicURLs[config.id] === musicData.url) {
                        const audioObj = resolveAudioObject(config.id);
                        if (audioObj && audioObj.audioElement && audioObj.audioElement.paused) {
                            playAudio(config.id);
                        }
                        return;
                    }

                    // 6. Carga de nueva m√∫sica (con debounce)
                    const now = Date.now();
                    if (lastLoadTime[config.id] && (now - lastLoadTime[config.id]) < 2000) return;

                    loadingInProgress[config.id] = true;
                    lastLoadTime[config.id] = now;

                    try {
                        console.log(`üéµ Sincronizando m√∫sica ${config.name}`);
                        await loadAudioFromURL(musicData.url, config.id);
                        playAudio(config.id);
                        loadedMusicURLs[config.id] = musicData.url;
                    } catch (error) {
                        console.error(`‚ùå Error cargando m√∫sica ${config.name}:`, error);
                    } finally {
                        loadingInProgress[config.id] = false;
                    }
                });
            });

            // Registrar listeners para decoraciones tipo RADIO
            decorationsConfig.forEach(config => {
                if (!config.radio) return;
                const musicRef = ref(database, `carGame/${config.id}Music`);
                onValue(musicRef, async (snapshot) => {
                    const musicData = snapshot.val();

                    if (!musicData) {
                        delete carMusicState[config.id]; // Limpiar estado tambi√©n
                        stopAudioLocally(config.id);
                        return;
                    }

                    // 1. Guardar estado SIEMPRE, independientemente de si el modelo carg√≥
                    carMusicState[config.id] = musicData;

                    const dec = loadedDecorations[config.id];
                    if (!dec) return; // Si no ha cargado el modelo, ya se aplicar√° al terminar de cargar (checkeo en loadDecorationFromConfig)

                    const audioObj = resolveAudioObject(config.id);
                    if (!audioObj) return;

                    // 2. Aplicar ajustes

                    // 2. Aplicar ajustes
                    audioObj.maxVolume = musicData.volume !== undefined ? musicData.volume : 1.0;
                    audioObj.bassSensitivity = musicData.bassSensitivity !== undefined ? musicData.bassSensitivity : 0.8;

                    if (audioObj.audioElement) {
                        if (audioObj.isPlaying && audioObj.audioElement.paused && loadedMusicURLs[config.id] === musicData.url) {
                            playAudio(config.id);
                        }
                    }

                    // 3. Si YO puse esta m√∫sica, no recargar
                    if (musicData.playerId === currentPlayerId) {
                        loadedMusicURLs[config.id] = musicData.url;
                        return;
                    }

                    // 4. Si est√° ocupado o ya cargado
                    if (loadingInProgress[config.id]) return;
                    if (loadedMusicURLs[config.id] === musicData.url) {
                        if (dec.audio.audioElement && dec.audio.audioElement.paused) {
                            playAudio(config.id);
                        }
                        return;
                    }

                    // 5. Carga
                    const now = Date.now();
                    if (lastLoadTime[config.id] && (now - lastLoadTime[config.id]) < 2000) return;

                    loadingInProgress[config.id] = true;
                    lastLoadTime[config.id] = now;

                    try {
                        console.log(`üéµ Sincronizando m√∫sica en bocina: ${config.name}`);
                        await loadAudioFromURL(musicData.url, config.id);
                        playAudio(config.id);
                        loadedMusicURLs[config.id] = musicData.url;
                    } catch (error) {
                        console.error(`‚ùå Error en bocina ${config.name}:`, error);
                    } finally {
                        loadingInProgress[config.id] = false;
                    }
                });
            });
        }

        // Actualizar panel de jugadores
        function updatePlayersList(players) {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';

            let count = 0;
            Object.keys(players).forEach(playerId => {
                const player = players[playerId];
                const div = document.createElement('div');
                div.className = 'player-item' + (playerId === currentPlayerId ? ' self' : '');

                div.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div class="player-status">Modo: ${player.mode === 'player' ? 'üö∂ Jugador' : 'üöó Auto'}</div>
                `;

                playersList.appendChild(div);
                count++;
            });

            // Actualizar t√≠tulo con conteo
            document.querySelector('#playersPanel h3').textContent = `üë• Jugadores Online (${count})`;
        }

        // Crear el modelo 3D para otro jugador
        function createOtherPlayerModel(playerData) {
            const group = new THREE.Group();

            // Crear modelo simple de jugador (cilindro + esfera)
            const bodyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00aaff });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.75;
            body.castShadow = true;
            body.name = 'playerBody'; // Identificador para controlar visibilidad
            group.add(body);

            const headGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.8;
            head.castShadow = true;
            head.name = 'playerHead'; // Identificador para controlar visibilidad
            group.add(head);

            // Etiqueta con nombre
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(playerData.name, 128, 42);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(2, 0.5, 1);
            sprite.position.y = 2.5;
            sprite.name = 'playerNameTag'; // Identificador para la etiqueta
            group.add(sprite);

            return group;
        }

        // Actualizar la posici√≥n de otro jugador
        function updateOtherPlayer(playerId, playerData) {
            if (!otherPlayers[playerId]) {
                // Crear nuevo modelo si no existe
                const model = createOtherPlayerModel(playerData);
                model.position.set(playerData.x, playerData.y, playerData.z);

                // Configurar visibilidad inicial
                const body = model.getObjectByName('playerBody');
                const head = model.getObjectByName('playerHead');
                if (body) body.visible = (playerData.mode === 'player');
                if (head) head.visible = (playerData.mode === 'player');

                scene.add(model);
                otherPlayers[playerId] = {
                    model,
                    data: playerData,
                    targetPos: new THREE.Vector3(playerData.x, playerData.y, playerData.z),
                    targetRotation: playerData.rotation || 0,
                    velocity: new THREE.Vector3(0, 0, 0)
                };
            } else {
                // Actualizar posici√≥n existente con interpolaci√≥n suave mejorada
                const player = otherPlayers[playerId];

                // Mostrar/ocultar cuerpo seg√∫n el modo (el nombre siempre visible)
                const body = player.model.getObjectByName('playerBody');
                const head = player.model.getObjectByName('playerHead');
                const nameTag = player.model.getObjectByName('playerNameTag');

                if (body) body.visible = (playerData.mode === 'player');
                if (head) head.visible = (playerData.mode === 'player');
                // nameTag siempre visible

                // Si est√° en el auto o sentado, ajustar posici√≥n del nombre
                if (nameTag) {
                    if (playerData.mode === 'car') nameTag.position.y = 4;
                    else if (playerData.isSitting) nameTag.position.y = 1.5;
                    else nameTag.position.y = 2.5;
                }

                // Efecto visual de sentado (bajar el modelo)
                if (body) body.position.y = playerData.isSitting ? 0.35 : 0.75;
                if (head) head.position.y = playerData.isSitting ? 1.0 : 1.5;

                // Calcular velocidad para predicci√≥n
                const oldTarget = player.targetPos.clone();
                player.targetPos.set(playerData.x, playerData.y, playerData.z);
                player.targetRotation = playerData.rotation || 0;
                const oldTimestamp = (player.data && typeof player.data.timestamp === 'number') ? player.data.timestamp : (playerData.timestamp || Date.now());
                const newTimestamp = (typeof playerData.timestamp === 'number') ? playerData.timestamp : Date.now();
                const dt = Math.max(0.001, (newTimestamp - oldTimestamp) / 1000);
                player.velocity.subVectors(player.targetPos, oldTarget).multiplyScalar(1 / dt);

                player.data = playerData;
            }
        }

        // Eliminar jugador que se desconect√≥
        function removeOtherPlayer(playerId) {
            if (otherPlayers[playerId]) {
                scene.remove(otherPlayers[playerId].model);
                delete otherPlayers[playerId];
            }
        }

        // Actualizar posici√≥n del jugador actual en Firebase
        function updateMyPosition() {
            if (!isOnline || !currentPlayerId) return;

            const now = Date.now();
            if (now - lastUpdateTime < UPDATE_INTERVAL) return;

            const playerRef = ref(database, `carGame/players/${currentPlayerId}`);

            let posX, posY, posZ, rotation, mode;

            if (isPlayerMode) {
                const pos = controls.getObject().position;
                posX = pos.x;
                posY = pos.y;
                posZ = pos.z;
                rotation = 0;
                mode = 'player';
            } else {
                // Usar el auto activo (el que realmente est√°s manejando)
                const activeCar = activeCarContainer || carContainer;
                posX = activeCar.position.x;
                posY = activeCar.position.y;
                posZ = activeCar.position.z;
                rotation = activeCar.rotation.y;
                mode = 'car';
            }

            // Solo enviar si hay cambios significativos
            const posChanged = Math.abs(posX - lastSentPosition.x) > MIN_POSITION_CHANGE ||
                Math.abs(posY - lastSentPosition.y) > MIN_POSITION_CHANGE ||
                Math.abs(posZ - lastSentPosition.z) > MIN_POSITION_CHANGE;
            const rotChanged = Math.abs(rotation - lastSentPosition.rotation) > MIN_ROTATION_CHANGE;
            const modeChanged = mode !== lastSentPosition.mode;
            const sittingChanged = isSitting !== lastSentPosition.isSitting;

            // Solo actualizar si hay cambios significativos O si ha pasado tiempo (Heartbeat de 3s)
            const isHeartbeat = (now - lastUpdateTime > 3000);

            if (posChanged || rotChanged || modeChanged || sittingChanged || isHeartbeat) {
                const updateData = {
                    name: currentPlayerName, // IMPORTANTE: Incluir nombre para no borrarlo
                    x: Number(posX.toFixed(2)),
                    y: Number(posY.toFixed(2)),
                    z: Number(posZ.toFixed(2)),
                    rotation: Number(rotation.toFixed(2)),
                    mode: mode,
                    carId: currentCarId || null,
                    isSitting: isSitting,
                    timestamp: now
                };

                set(playerRef, updateData);

                lastSentPosition = { x: posX, y: posY, z: posZ, rotation: rotation, mode: mode, isSitting: isSitting };
                lastUpdateTime = now;
            }
        }

        function sitDown(sillaId) {
            const dec = loadedDecorations[sillaId];
            if (!dec || !dec.container) return;

            isSitting = true;
            currentSillaId = sillaId;

            // Posicionar al jugador en la silla
            const pos = dec.container.position;
            // Ajustar altura para que parezca sentado (subido de 0.5 a 0.85)
            controls.getObject().position.set(pos.x, pos.y + 0.85, pos.z);

            document.getElementById('status').innerText = 'ü™ë Sentado - E para pararse';
            console.log(`ü™ë Sentado en ${dec.name}`);

            // Registrar ocupaci√≥n en Firebase
            if (isOnline) {
                const sillaRef = ref(database, `carGame/sillas/${sillaId}`);
                set(sillaRef, {
                    playerId: currentPlayerId,
                    playerName: currentPlayerName,
                    timestamp: Date.now()
                });
                onDisconnect(sillaRef).remove();
            }
        }

        function standUp() {
            if (!isSitting) return;

            const wasSillaId = currentSillaId;

            // Mover al jugador a un lado de la silla para no quedar atrapado en la hitbox
            const dec = loadedDecorations[currentSillaId];
            if (dec && dec.container) {
                const pos = dec.container.position;
                const rot = dec.container.rotation.y;
                // Salir por el lado derecho de la silla
                const exitX = pos.x + Math.cos(rot) * 1.5;
                const exitZ = pos.z + Math.sin(rot) * 1.5;
                controls.getObject().position.set(exitX, 1.7, exitZ);
            } else {
                controls.getObject().position.y = 1.7;
            }

            isSitting = false;
            currentSillaId = null;
            document.getElementById('status').innerText = 'Modo Jugador - F para m√∫sica';
            console.log("üö∂ De pie");

            // Liberar ocupaci√≥n en Firebase
            if (isOnline && wasSillaId) {
                remove(ref(database, `carGame/sillas/${wasSillaId}`));
            }
        }

        // Verificar si la silla est√° libre
        async function checkSillaAvailability(sillaId) {
            if (!isOnline) return true;
            try {
                const sillaRef = ref(database, `carGame/sillas/${sillaId}`);
                const snapshot = await get(sillaRef);
                if (!snapshot.exists()) return true;

                // Si ya estoy yo, est√° disponible (por si acaso)
                if (snapshot.val().playerId === currentPlayerId) return true;

                return false;
            } catch (error) {
                return true;
            }
        }

        // Verificar si el auto est√° disponible (conductor o pasajero)
        async function checkCarAvailability(carId = 'car1') {
            if (!isOnline) return { canJoin: true, role: 'driver' }; // Si no est√° online, siempre disponible

            try {
                // Usar referencia separada por auto
                const carRef = ref(database, `carGame/${carId}Occupants`);
                const snapshot = await get(carRef);

                if (!snapshot.exists()) {
                    return { canJoin: true, role: 'driver' }; // Auto libre, ser conductor
                }

                const occupants = snapshot.val();
                const occupantsList = Object.values(occupants);

                // Si ya estoy en el auto, permitir
                if (occupants[currentPlayerId]) {
                    return { canJoin: true, role: occupants[currentPlayerId].role };
                }

                // L√≠mite: 1 conductor + 3 pasajeros = 4 personas m√°ximo
                if (occupantsList.length >= 4) {
                    return { canJoin: false, role: null }; // Auto lleno
                }

                // Verificar si ya hay conductor
                const hasDriver = occupantsList.some(o => o.role === 'driver');

                if (!hasDriver) {
                    return { canJoin: true, role: 'driver' }; // Ser conductor
                } else {
                    return { canJoin: true, role: 'passenger' }; // Ser pasajero
                }
            } catch (error) {
                console.error('Error verificando disponibilidad del auto:', error);
                return { canJoin: true, role: 'driver' }; // En caso de error, permitir
            }
        }

        // Event listener para el bot√≥n de login
        document.getElementById('joinBtn').addEventListener('click', joinGame);

        // Permitir Enter para unirse
        document.getElementById('playerName').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinGame();
            }
        });

        // ===== SISTEMA DE AUDIO BASADO EN EL EJEMPLO DEL USUARIO =====
        function initAudioContext() {
            if (audioContext) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log("AudioContext iniciado conforme al est√°ndar Web Audio API.");
            } catch (e) {
                console.error("Error al iniciar AudioContext:", e);
            }
        }

        // Funci√≥n helper para obtener el objeto de audio de cualquier ID (Auto o Decoraci√≥n)
        function resolveAudioObject(id) {
            if (!id) return null;
            let audioObj = null;

            // 1. Buscar en autos cargados din√°micamente
            if (loadedCars[id] && loadedCars[id].audio) {
                audioObj = loadedCars[id].audio;
            }
            // 2. Buscar en decoraciones (bocinas)
            else if (loadedDecorations[id] && loadedDecorations[id].audio) {
                audioObj = loadedDecorations[id].audio;
            }
            // 3. Fallback a variables globales legacy
            else {
                const legacy = {
                    'car1': car1Audio, 'car2': car2Audio, 'car3': car3Audio,
                    'car4': car4Audio, 'car5': car5Audio, 'car6': car6Audio, 'car7': car7Audio
                };
                audioObj = legacy[id];
            }

            if (!audioObj) {
                console.warn(`‚ö†Ô∏è No se pudo resolver objeto de audio para: ${id}`);
            }
            return audioObj;
        }

        // Funci√≥n auxiliar para configurar el analizador (API Est√°ndar)
        function setupAnalyser(audioObj) {
            if (!audioContext || audioObj.analyser) return;
            try {
                audioObj.analyser = audioContext.createAnalyser();
                audioObj.analyser.fftSize = 256;
                const bufferLength = audioObj.analyser.frequencyBinCount;
                audioObj.dataArray = new Uint8Array(bufferLength);
                audioObj.gainNode = audioContext.createGain();
                audioObj.gainNode.connect(audioContext.destination);

                // IMPORTANTE: Conectar el elemento de audio al analizador
                if (audioObj.audioElement && !audioObj.audioSource) {
                    audioObj.audioSource = audioContext.createMediaElementSource(audioObj.audioElement);

                    // Crear nodo de paneo est√©reo (Spatial Audio simplificado)
                    if (!audioObj.pannerNode) {
                        audioObj.pannerNode = audioContext.createStereoPanner();
                    }

                    // Conexiones: Fuente -> Analizador -> Paneo -> Ganancia -> Destino
                    audioObj.audioSource.connect(audioObj.analyser);
                    audioObj.analyser.connect(audioObj.pannerNode);
                    audioObj.pannerNode.connect(audioObj.gainNode);
                }
            } catch (e) {
                console.error("Error setting up analyser:", e);
            }
        }

        // Cargar audio desde URL - Siguiendo el patr√≥n de liberar streams del ejemplo
        async function loadAudioFromURL(url, carId = 'car1') {
            try {
                musicStatusText.textContent = '‚è≥ Cargando m√∫sica...';

                const audioObj = resolveAudioObject(carId);
                if (!audioObj) throw new Error(`Objeto de audio no encontrado para ${carId}`);

                console.log(`üì° [API Nueva] Configurando stream para ${carId}...`);

                // Para evadir el l√≠mite de streams, CREAMOS UN NUEVO ELEMENTO cada vez (como en tu ejemplo)
                if (audioObj.audioElement) {
                    audioObj.audioElement.pause();
                    audioObj.audioElement.src = "";
                }

                // Limpiar conexiones viejas si existen para liberar el slot y forzar re-conexi√≥n
                if (audioObj.audioSource) {
                    try { audioObj.audioSource.disconnect(); } catch (e) { }
                    audioObj.audioSource = null;
                }
                if (audioObj.gainNode) {
                    try { audioObj.gainNode.disconnect(); } catch (e) { }
                    audioObj.gainNode = null;
                }
                audioObj.analyser = null; // Forzar que setupAnalyser cree uno nuevo ligado al nuevo stream

                audioObj.audioElement = new Audio(url);
                audioObj.audioElement.crossOrigin = "anonymous";
                audioObj.audioElement.load();
                audioObj.audioElement.volume = audioObj.maxVolume;

                musicStatusText.textContent = '‚úÖ M√∫sica lista';
                return true;
            } catch (error) {
                console.error(`‚ùå Error configurando audio para ${carId}:`, error.message);
                musicStatusText.textContent = `‚ùå Error: ${error.message}`;
                throw error;
            }
        }

        // ===== FUNCIONES DE YOUTUBE =====

        // Detectar si es un link de YouTube
        function isYouTubeURL(url) {
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?\&]v=)|youtu\.be\/)([^"\&?\/\s]{11})/;
            return youtubeRegex.test(url);
        }

        // Extraer video ID de YouTube
        function getYouTubeVideoID(url) {
            const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?\&]v=)|youtu\.be\/)([^"\&?\/\s]{11})/;
            const match = url.match(youtubeRegex);
            return match ? match[1] : null;
        }

        // Reproducir YouTube (simplificado)
        function playYouTube(videoID) {
            console.log('YouTube playback simplificado:', videoID);
        }

        // Detener YouTube
        function stopYouTube() {
            console.log('YouTube detenido');
        }

        // Reproducir audio - SIMPLIFICADO para elementos HTML
        function playAudio(carId = 'car1') {
            // Asegurar que el contexto de audio exista y est√© activo
            initAudioContext();
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const audioObj = resolveAudioObject(carId);
            if (!audioObj || !audioObj.audioElement) return;

            // ASEGURAR Web Audio (Configurar al momento de reproducir)
            if (audioContext && !audioObj.audioSource) {
                setupAnalyser(audioObj);
            }

            const playPromise = audioObj.audioElement.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    audioObj.isPlaying = true;
                }).catch(err => {
                    if (err.name !== 'AbortError') console.error(`Error reproduciendo ${carId}:`, err);
                });
            }
        }

        // Nueva funci√≥n unificada para detener y liberar el slot a petici√≥n del usuario
        function stopAudioLocally(carId) {
            const audioObj = resolveAudioObject(carId);
            if (!audioObj) return;

            if (audioObj.audioElement) {
                audioObj.audioElement.pause();
                audioObj.audioElement.src = "";
                try { audioObj.audioElement.load(); } catch (e) { }
                // IMPORTANTE: Un elemento conectado a WebAudio no se puede reconectar.
                // Creamos uno nuevo para "limpiar" el slot del navegador.
                audioObj.audioElement = new Audio();
                audioObj.audioElement.crossOrigin = "anonymous";
            }

            if (audioObj.audioSource) {
                try {
                    audioObj.audioSource.disconnect();
                } catch (e) { }
                audioObj.audioSource = null;
            }
            if (audioObj.gainNode) {
                try { audioObj.gainNode.disconnect(); } catch (e) { }
                audioObj.gainNode = null;
            }
            audioObj.analyser = null; // Limpiar para liberar recursos

            audioObj.isPlaying = false;
            audioObj.bounce = 0;
        }
        function getBassLevel(carId = 'car1') {
            const audioObj = resolveAudioObject(carId);
            if (!audioObj || !audioObj.isPlaying || !audioObj.analyser || !audioObj.dataArray) return 0;

            try {
                audioObj.analyser.getByteFrequencyData(audioObj.dataArray);
                let sum = 0;
                // Analizar un rango un poco m√°s amplio de bajos (0-20) para mayor precisi√≥n
                for (let i = 0; i < 20; i++) sum += audioObj.dataArray[i];
                let level = (sum / 20) / 255;
                // Aumentar un poco la intensidad base para el rebote visual
                return level * (audioObj.bassSensitivity || 0.5) * 2.0;
            } catch (e) { return 0; }
        }

        // Sistema de m√∫sica
        const musicMenu = document.getElementById('musicMenu');
        const musicUrl = document.getElementById('musicUrl');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const closeBtn = document.getElementById('closeBtn');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        const bassSensitivitySlider = document.getElementById('bassSensitivity');
        const bassValue = document.getElementById('bassValue');
        const musicStatusText = document.getElementById('musicStatusText');
        const musicInfo = document.getElementById('musicInfo');
        const bassLevelSpan = document.getElementById('bassLevel');

        let is3DAudioEnabled = false; // Variable para control de audio 3D
        const audio3DCheckbox = document.getElementById('audio3DCheckbox');

        audio3DCheckbox.addEventListener('change', (e) => {
            is3DAudioEnabled = e.target.checked;
        });

        volumeSlider.addEventListener('input', (e) => {
            const newVolume = e.target.value / 100;
            volumeValue.textContent = e.target.value;

            const target = loadedCars[currentAudioTarget] || loadedDecorations[currentAudioTarget];
            if (currentAudioTarget && target) {
                const audioObj = target.audio;
                audioObj.maxVolume = newVolume;
                if (audioObj.audioElement) {
                    audioObj.audioElement.volume = newVolume;
                }
            }
        });

        volumeSlider.addEventListener('change', (e) => {
            if (isOnline && currentAudioTarget) {
                const target = loadedCars[currentAudioTarget] || loadedDecorations[currentAudioTarget];
                if (target && target.audio) {
                    dbUpdate(ref(database, `carGame/${currentAudioTarget}Music`), {
                        volume: target.audio.maxVolume
                    });
                }
            }
        });

        bassSensitivitySlider.addEventListener('input', (e) => {
            const newSensitivity = e.target.value / 100;
            bassValue.textContent = e.target.value;

            const target = loadedCars[currentAudioTarget] || loadedDecorations[currentAudioTarget];
            if (currentAudioTarget && target) {
                target.audio.bassSensitivity = newSensitivity;
                // Tambi√©n actualizar carMusicState local
                if (carMusicState[currentAudioTarget]) {
                    carMusicState[currentAudioTarget].bassSensitivity = newSensitivity;
                }
            }
        });

        bassSensitivitySlider.addEventListener('change', (e) => {
            if (isOnline && currentAudioTarget) {
                const target = loadedCars[currentAudioTarget] || loadedDecorations[currentAudioTarget];
                if (target && target.audio) {
                    dbUpdate(ref(database, `carGame/${currentAudioTarget}Music`), {
                        bassSensitivity: target.audio.bassSensitivity
                    });
                }
            }
        });

        playBtn.addEventListener('click', async () => {
            const url = musicUrl.value.trim();
            if (!url) {
                alert('Por favor ingresa un link de m√∫sica');
                return;
            }

            if (!currentAudioTarget) {
                alert('Por favor ac√©rcate a un auto y presiona F primero');
                return;
            }

            try {
                initAudioContext();

                playBtn.disabled = true;
                playBtn.textContent = '‚è≥ Cargando...';

                const audioObj = resolveAudioObject(currentAudioTarget);

                if (!audioObj) {
                    throw new Error("No se encontr√≥ el objeto de audio del objetivo");
                }

                // Actualizar tracking global para evitar que el listener de Firebase recargue lo que ya estamos cargando aqu√≠
                loadingInProgress[currentAudioTarget] = true;
                lastLoadTime[currentAudioTarget] = Date.now();
                loadedMusicURLs[currentAudioTarget] = url;

                await loadAudioFromURL(url, currentAudioTarget);
                playAudio(currentAudioTarget);

                loadingInProgress[currentAudioTarget] = false;

                musicStatusText.textContent = 'üéµ ¬°Reproduciendo con Bass Boost!';
                musicInfo.textContent = 'üéµ M√∫sica activa - Bass detectado';
                playBtn.textContent = '‚ñ∂Ô∏è Reproducir';
                playBtn.disabled = false;

                // Guardar m√∫sica en Firebase para que todos la escuchen EN ESTE AUTO ESPEC√çFICO
                if (isOnline && currentAudioTarget) {
                    const musicPath = `carGame/${currentAudioTarget}Music`;
                    const musicRef = ref(database, musicPath);
                    set(musicRef, {
                        url: url,
                        playerId: currentPlayerId,
                        playerName: currentPlayerName,
                        timestamp: Date.now(),
                        volume: audioObj.maxVolume,
                        bassSensitivity: audioObj.bassSensitivity
                    });
                }

            } catch (error) {
                console.error('Error:', error);
                musicStatusText.textContent = '‚ùå Error al cargar m√∫sica';
                alert('No se pudo cargar la m√∫sica. Aseg√∫rate de que el link sea un archivo de audio v√°lido (.mp3, .wav, etc.)');
                playBtn.textContent = '‚ñ∂Ô∏è Reproducir';
                playBtn.disabled = false;
            }
        });

        stopBtn.addEventListener('click', () => {
            if (!currentAudioTarget) return;

            let audioObj = null;
            if (loadedCars[currentAudioTarget]) audioObj = loadedCars[currentAudioTarget].audio;
            else if (loadedDecorations[currentAudioTarget]) audioObj = loadedDecorations[currentAudioTarget].audio;

            if (!audioObj) return;

            // DETENER Y LIBERAR SLOT (Como en tu ejemplo)
            if (audioObj.audioElement) {
                audioObj.audioElement.pause();
                audioObj.audioElement.src = "";
                audioObj.audioElement.load();
            }

            if (audioObj.audioSource) {
                audioObj.audioSource.disconnect();
                audioObj.audioSource = null;
            }

            audioObj.isPlaying = false;
            audioObj.bounce = 0;

            if (youtubePlayer) stopYouTube();

            currentMusicType = null;
            musicStatusText.textContent = '‚è∏Ô∏è M√∫sica detenida';
            musicInfo.textContent = '';
            bassLevelSpan.textContent = '0';

            if (isOnline && currentAudioTarget) {
                remove(ref(database, `carGame/${currentAudioTarget}Music`));
            }
        });

        const closeMenuHandler = (e) => {
            if (e) e.preventDefault();
            musicMenu.style.display = 'none';
            isMusicMenuOpen = false;
        };
        closeBtn.addEventListener('click', closeMenuHandler);
        closeBtn.addEventListener('touchstart', closeMenuHandler);

        // Funci√≥n para actualizar qu√© audios deben reproducirse seg√∫n proximidad (L√≠mite de 5)
        function updateAudioPriority() {
            // Obtener posici√≥n del jugador
            let playerPos;
            if (isPlayerMode) {
                playerPos = controls.getObject().position;
            } else if (activeCarContainer) {
                playerPos = activeCarContainer.position;
            } else {
                return;
            }

            // Crear array con todos los objetos que tienen m√∫sica asignada
            const audioSources = [];

            // Agregar todos los autos con m√∫sica activa (que tengan un src)
            Object.values(loadedCars).forEach(carData => {
                const audio = carData.audio;
                if (audio && audio.audioElement && audio.audioElement.src && carData.container) {
                    const distance = playerPos.distanceTo(carData.container.position);
                    audioSources.push({
                        id: carData.id,
                        name: carData.name,
                        audio: audio,
                        distance: distance
                    });
                }
            });

            // Agregar decoraciones con m√∫sica (bocinas, radios)
            Object.values(loadedDecorations).forEach(dec => {
                if (dec.radio && dec.audio && dec.audio.audioElement && dec.audio.audioElement.src && dec.container) {
                    const distance = playerPos.distanceTo(dec.container.position);
                    audioSources.push({
                        id: dec.id,
                        name: dec.name,
                        audio: dec.audio,
                        distance: distance
                    });
                }
            });

            // Ordenar por distancia (m√°s cercanos primero)
            audioSources.sort((a, b) => a.distance - b.distance);

            // Determinar cu√°les deben reproducirse (los 5 m√°s cercanos)
            const shouldPlaySet = new Set();
            const priorityList = audioSources.slice(0, MAX_CONCURRENT_AUDIOS);

            priorityList.forEach(source => {
                shouldPlaySet.add(source.id);
            });

            // Activar/desactivar audios seg√∫n prioridad
            audioSources.forEach(source => {
                const shouldPlay = shouldPlaySet.has(source.id);
                // Usamos una flag interna para no entrar en bucle con el evento onplay
                const isPaused = source.audio.audioElement.paused;

                if (shouldPlay) {
                    if (isPaused) {
                        // Este audio debe reproducirse pero est√° pausado
                        source.audio.audioElement.play().then(() => {
                            source.audio.isPlaying = true;
                            activeAudioSources.add(source.id);
                            // console.log(`üîä Reproduciendo ${source.name} (${source.distance.toFixed(1)}m)`);
                        }).catch(err => {
                            if (err.name !== 'AbortError') console.warn(`No se pudo reproducir ${source.name}:`, err);
                        });
                    }
                } else {
                    if (!isPaused) {
                        // Este audio debe pausarse porque est√° lejos
                        source.audio.audioElement.pause();
                        source.audio.isPlaying = false;
                        activeAudioSources.delete(source.id);
                        // console.log(`üîá Pausando ${source.name} (${source.distance.toFixed(1)}m)`);
                    }
                }
            });
        }

        // Funci√≥n para ajustar volumen seg√∫n distancia - TODOS LOS AUTOS DIN√ÅMICAMENTE (OPTIMIZADA)
        function updateAudioVolume() {
            // 1. Actualizar prioridades (qui√©n suena y qui√©n no por l√≠mite de navegador)
            updateAudioPriority();

            // 2. Obtener posici√≥n del jugador una sola vez
            let playerPos;
            if (isPlayerMode) {
                playerPos = controls.getObject().position;
            } else if (activeCarContainer) {
                playerPos = activeCarContainer.position;
            } else {
                return;
            }

            const maxDistance = 50;
            const minDistance = 5;
            const distanceRange = maxDistance - minDistance;

            // Iterar sobre TODOS los autos cargados
            Object.values(loadedCars).forEach(carData => {
                if (carData.audio && carData.audio.audioElement && carData.container) {
                    let volumeFactor = 1;

                    // Si estoy DENTRO de ESTE auto, volumen 100%
                    if (!isPlayerMode && currentCarId === carData.id) {
                        volumeFactor = 1;
                    } else {
                        // Calcular por distancia (optimizado: evitar crear Vector3 innecesarios)
                        const dx = playerPos.x - carData.container.position.x;
                        const dy = playerPos.y - carData.container.position.y;
                        const dz = playerPos.z - carData.container.position.z;
                        const distSq = dx * dx + dy * dy + dz * dz;
                        const dist = Math.sqrt(distSq);

                        if (dist <= minDistance) {
                            volumeFactor = 1;
                        } else if (dist >= maxDistance) {
                            volumeFactor = 0;
                        } else {
                            // calcular volumen
                            volumeFactor = 1 - (dist - minDistance) / distanceRange;
                        }

                        // --- SPATIAL AUDIO (PANEO 3D) ---
                        if (carData.audio.pannerNode) {
                            // Vector del jugador al auto
                            const toCar = new THREE.Vector3().subVectors(carData.container.position, playerPos).normalize();

                            // Vector de direcci√≥n de la c√°mara (hacia d√≥nde mira)
                            const camDir = new THREE.Vector3();
                            camera.getWorldDirection(camDir);

                            // Vector "Derecha" de la c√°mara (Producto cruz)
                            const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0, 1, 0));

                            // Producto punto para saber qu√© tanto a la derecha est√° el auto
                            // -1 (Izquierda) a 1 (Derecha)
                            let panValue = toCar.dot(camRight);

                            // Ajustar intensidad del paneo
                            carData.audio.pannerNode.pan.value = is3DAudioEnabled ? panValue : 0;
                        }
                    }

                    // Usar GainNode para volumen por distancia si est√° disponible (mejor para el analizador)
                    const targetVolume = (carData.audio.maxVolume !== undefined ? carData.audio.maxVolume : 1.0) * volumeFactor;

                    if (carData.audio.gainNode) {
                        // Usar rampa suave para evitar clicks
                        carData.audio.gainNode.gain.setTargetAtTime(targetVolume, audioContext.currentTime, 0.05);
                        // Mantener el volumen del elemento al m√°ximo para que el analizador reciba se√±al completa
                        if (carData.audio.audioElement.volume !== 1.0) carData.audio.audioElement.volume = 1.0;
                    } else if (carData.audio.audioElement) {
                        // Fallback si no hay Web Audio
                        if (Math.abs(carData.audio.audioElement.volume - targetVolume) > 0.01) {
                            carData.audio.audioElement.volume = targetVolume;
                        }
                    }
                }
            });

            Object.values(loadedDecorations).forEach(dec => {
                try {
                    if (dec.radio && dec.audio && dec.audio.audioElement && dec.container) {
                        const dist = playerPos.distanceTo(dec.container.position);
                        let volumeFactor = 0;

                        if (dist <= minDistance) {
                            volumeFactor = 1;
                        } else if (dist >= maxDistance) {
                            volumeFactor = 0;
                        } else {
                            volumeFactor = 1 - (dist - minDistance) / distanceRange;
                        }

                        // --- SPATIAL AUDIO (PANEO 3D) PARA DECORACIONES ---
                        if (dec.audio.pannerNode) {
                            if (is3DAudioEnabled) {
                                const toDec = new THREE.Vector3().subVectors(dec.container.position, playerPos).normalize();
                                const camDir = new THREE.Vector3();
                                camera.getWorldDirection(camDir);
                                const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0, 1, 0));
                                let panValue = toDec.dot(camRight);
                                dec.audio.pannerNode.pan.value = is3DAudioEnabled ? panValue : 0;
                            } else {
                                dec.audio.pannerNode.pan.value = 0;
                            }
                        }

                        // Aplicar volumen
                        const targetVolume = (dec.audio.maxVolume !== undefined ? dec.audio.maxVolume : 1.0) * volumeFactor;

                        // Priorizar GainNode
                        if (dec.audio.gainNode) {
                            dec.audio.gainNode.gain.setTargetAtTime(targetVolume, audioContext.currentTime, 0.05);
                            // Audio element al 100% para que el analyzer funcione
                            if (dec.audio.audioElement.volume !== 1.0) dec.audio.audioElement.volume = 1.0;
                        } else {
                            if (Math.abs(dec.audio.audioElement.volume - targetVolume) > 0.01) {
                                dec.audio.audioElement.volume = targetVolume;
                            }
                        }
                    }
                } catch (e) {
                    // Silenciar errores individuales
                }
            });
        }

        // Funci√≥n para hacer rebotar los autos con el bass - TODOS LOS AUTOS DIN√ÅMICAMENTE
        function updateCarBounce() {
            // Iterar sobre TODOS los autos cargados
            Object.values(loadedCars).forEach(carData => {
                if (carData.container && carData.audio) {
                    const bassLevel = getBassLevel(carData.id);

                    // Si el bass level es 0, no aplicar rebote y resetear posici√≥n
                    if (bassLevel <= 0) {
                        if (typeof carData.audio.bounce !== 'number') {
                            carData.audio.bounce = 0;
                        } else {
                            // Suavizar el retorno a la posici√≥n base
                            carData.audio.bounce *= 0.9;
                            if (Math.abs(carData.audio.bounce) < 0.01) {
                                carData.audio.bounce = 0;
                            }
                        }
                        carData.container.position.y = carData.baseY + carData.audio.bounce;
                        carData.container.rotation.z *= 0.9;
                        return; // Saltar al siguiente auto
                    }

                    const sensitivity = carData.audio.bassSensitivity !== undefined ? carData.audio.bassSensitivity : 0.5;

                    // Intensidad crece m√°s fuerte que lineal con la sensibilidad
                    const intensity = sensitivity;
                    const intensityPower = Math.pow(intensity, 1.5);
                    const targetBounce = bassLevel * intensityPower * 1.5;

                    if (typeof carData.audio.bounce !== 'number') {
                        carData.audio.bounce = 0;
                    }

                    // A menor sensibilidad, m√°s suave; a mayor sensibilidad, m√°s brusco
                    const smoothFactor = 0.45 - intensity * 0.3; // ~0.45 en 0, ~0.30 en 0.5, ~0.15 en 1
                    carData.audio.bounce += (targetBounce - carData.audio.bounce) * smoothFactor;

                    // Aplicar rebote vertical SIEMPRE, para que todos los jugadores lo vean
                    carData.container.position.y = carData.baseY + carData.audio.bounce;

                    // Peque√±a rotaci√≥n en Z cuando hay mucho bass, visible tambi√©n desde fuera
                    if (bassLevel > 0.6 && sensitivity > 0.3) {
                        if (carData._shakePhase === undefined) {
                            carData._shakePhase = Math.random() * Math.PI * 2;
                        }
                        const shakeIntensity = 0.5 + sensitivity;
                        const shake = Math.sin(performance.now() * 0.05 + carData._shakePhase) * bassLevel * 0.02 * shakeIntensity;
                        carData.container.rotation.z = shake;
                    } else {
                        carData.container.rotation.z *= 0.9;
                    }
                }
            });

            // Rebote para DECORACIONES tipo radio (Bocina)
            Object.values(loadedDecorations).forEach(dec => {
                if (dec.radio && dec.container && dec.audio) {
                    const bassLevel = getBassLevel(dec.id);
                    if (bassLevel <= 0) {
                        dec.audio.bounce = (dec.audio.bounce || 0) * 0.9;
                        dec.container.position.y = dec.baseY + dec.audio.bounce;
                        dec.container.rotation.x *= 0.9;
                        dec.container.rotation.z *= 0.9;
                        return;
                    }
                    const sensitivity = dec.audio.bassSensitivity !== undefined ? dec.audio.bassSensitivity : 0.8;
                    // Usar curva exponencial para que solo los PICOS de bajos levanten la bocina
                    // Esto evita que "flote" con bajos constantes
                    const peakBass = Math.pow(bassLevel, 3);
                    const targetBounce = peakBass * sensitivity * 3.5; // Salto fuerte solo en los golpes
                    const currentBounce = dec.audio.bounce || 0;

                    // L√≥gica de Gravedad:
                    // Si el objetivo es MAYOR (golpe de bajo), subir con fuerza (0.4)
                    // Si el objetivo es MENOR (silencio), caer R√ÅPIDO al piso (0.85) para no flotar
                    const speed = targetBounce > currentBounce ? 0.4 : 0.85;

                    dec.audio.bounce = currentBounce + (targetBounce - currentBounce) * speed;
                    dec.container.position.y = dec.baseY + dec.audio.bounce;

                    // if (dec.audio.bounce > 0.5) {
                    //     console.log(`üîä Bocina saltando! Y: ${dec.container.position.y.toFixed(2)}`);
                    // }

                    // Vibraci√≥n agresiva si hay mucho bass
                    if (bassLevel > 0.5) {
                        dec.container.rotation.x = (Math.random() - 0.5) * 0.04 * bassLevel;
                        dec.container.rotation.z = (Math.random() - 0.5) * 0.04 * bassLevel;
                    }
                }
            });

            // Actualizar UI solo si estamos viendo el men√∫ de m√∫sica
            if (currentAudioTarget && (loadedCars[currentAudioTarget] || loadedDecorations[currentAudioTarget])) {
                const bassLevel = getBassLevel(currentAudioTarget);
                bassLevelSpan.textContent = Math.floor(bassLevel * 100);
            }
        }

        // Funci√≥n para manejar la visibilidad y posici√≥n del Radiobox
        async function updateRadioBoxes() {
            const radioBoxUrl = 'https://raw.githubusercontent.com/chipeosimulator/Modelos/main/Radiobox.glb';

            for (const [carId, carData] of Object.entries(loadedCars)) {
                if (!carData.audio) continue;

                // REGLA: Mostrar si hay m√∫sica Y el auto est√° vac√≠o (nadie dentro) Y el auto es visible (por distancia)
                const isOccupied = (!isPlayerMode && currentCarId === carId) ||
                    Object.values(otherPlayers).some(p => p.data && p.data.mode === 'car' && p.data.carId === carId);

                const shouldShow = carData.audio.isPlaying && !isOccupied && carData.container.visible;

                if (shouldShow) {
                    if (!carData.radioBox && !carData._isLoading) {
                        carData._isLoading = true;
                        try {
                            if (!modelCache[radioBoxUrl]) {
                                const loader = new GLTFLoader();
                                modelCache[radioBoxUrl] = new Promise((res, rej) => {
                                    loader.load(radioBoxUrl, (g) => res(g), undefined, (e) => rej(e));
                                });
                            }

                            const gltf = await modelCache[radioBoxUrl];
                            const rb = gltf.scene.clone();
                            rb.scale.set(2.5, 2.5, 2.5);
                            scene.add(rb);
                            carData.radioBox = rb;

                            rb.traverse(n => {
                                if (n.isMesh) {
                                    n.castShadow = true;
                                    n.receiveShadow = true;
                                }
                            });
                            carData._isLoading = false;
                        } catch (e) {
                            console.error("Error Radiobox:", e);
                            carData._isLoading = false;
                            continue;
                        }
                    }

                    if (carData.radioBox) {
                        const car = carData.container;
                        const rot = car.rotation.y;
                        const dist = 7.5; // Distancia aumentada

                        carData.radioBox.position.set(
                            car.position.x + Math.sin(rot) * dist,
                            1.3, // Altura elevada
                            car.position.z + Math.cos(rot) * dist
                        );
                        carData.radioBox.rotation.y = rot - Math.PI / 2;
                        carData.radioBox.visible = true;

                        // --- CABLE LOGIC ---
                        if (!carData.radioCable) {
                            const mat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
                            const geo = new THREE.BufferGeometry();
                            const mesh = new THREE.Mesh(geo, mat);
                            mesh.castShadow = true;
                            scene.add(mesh);
                            carData.radioCable = mesh;
                        }

                        // Puntos del cable
                        const start = carData.radioBox.position.clone();
                        start.y += 0.9; // Ajustado: Conexi√≥n m√°s arriba en la caja

                        // Conectar al frente del auto (bumper - parte baja)
                        const bumperDist = 2.4;
                        const end = car.position.clone();
                        end.x += Math.sin(rot) * bumperDist;
                        end.z += Math.cos(rot) * bumperDist;
                        end.y -= 1.35; // Ajuste fino

                        // Curva con ca√≠da (Slack) m√°s suave
                        const mid = new THREE.Vector3().lerpVectors(start, end, 0.5);
                        // Calcular ca√≠da relativa a la altura promedio, pero sin tocar el piso necesariamente
                        // Evita que haga una "V" muy pronunciada si los puntos est√°n altos
                        const lowestPoint = Math.min(start.y, end.y);
                        mid.y = Math.max(0.1, lowestPoint - 1.0); // Ca√≠da de 1 metro desde el punto m√°s bajo

                        const curve = new THREE.QuadraticBezierCurve3(start, mid, end);

                        // Actualizar tubo (geometry disposables para evitar fugas de memoria)
                        if (carData.radioCable.geometry) carData.radioCable.geometry.dispose();
                        carData.radioCable.geometry = new THREE.TubeGeometry(curve, 12, 0.035, 6, false);
                        carData.radioCable.visible = true;
                    }
                } else {
                    if (carData.radioBox) {
                        carData.radioBox.visible = false;
                    }
                    if (carData.radioCable) {
                        carData.radioCable.visible = false;
                    }
                }
            }
        }

        function checkCarCollision(newPosition) {
            if (!isPlayerMode) return false;

            const playerRadius = 0.5;

            // Verificar colisi√≥n con TODOS los autos din√°micamente
            for (const carData of Object.values(loadedCars)) {
                if (carData.collisionBox && carData.container) {
                    const carPos = carData.container.position;
                    const carRot = carData.container.rotation.y;

                    const dx = newPosition.x - carPos.x;
                    const dz = newPosition.z - carPos.z;

                    const localX = dx * Math.cos(-carRot) - dz * Math.sin(-carRot);
                    const localZ = dx * Math.sin(-carRot) + dz * Math.cos(-carRot);

                    const halfWidth = carData.collisionBox.width / 2;
                    const halfLength = carData.collisionBox.length / 2;

                    if (Math.abs(localX) < halfWidth + playerRadius &&
                        Math.abs(localZ) < halfLength + playerRadius) {
                        return true; // Colisi√≥n detectada con auto
                    }
                }
            }

            // Verificar colisi√≥n con DECORACIONES (Edificios, etc)
            for (const dec of Object.values(loadedDecorations)) {
                if (dec.hasCollision && dec.container) {
                    const pos = dec.container.position;
                    const rot = dec.container.rotation.y;

                    const dx = newPosition.x - pos.x;
                    const dz = newPosition.z - pos.z;

                    const localX = dx * Math.cos(-rot) - dz * Math.sin(-rot);
                    const localZ = dx * Math.sin(-rot) + dz * Math.cos(-rot);

                    if (Math.abs(localX) < (dec.collisionBox.width / 2) + playerRadius &&
                        Math.abs(localZ) < (dec.collisionBox.length / 2) + playerRadius) {
                        return true; // Colisi√≥n detectada con edificio/prop
                    }
                }
            }

            return false; // Sin colisi√≥n
        }

        // 7. CONTROLES
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (key === 'w') moveForward.active = true;
            if (key === 's') moveBackward.active = true;
            if (key === 'a') moveLeft.active = true;
            if (key === 'd') moveRight.active = true;

            if (e.key === 'ArrowUp') moveForward.active = true;
            if (e.key === 'ArrowDown') moveBackward.active = true;
            if (e.key === 'ArrowLeft') moveLeft.active = true;
            if (e.key === 'ArrowRight') moveRight.active = true;

            // Nitro con Shift (solo cuando est√°s manejando)
            if (e.key === 'Shift' && !isPlayerMode && carRole === 'driver') {
                shiftKeyPressed = true;
            }

            if (key === 'l') {
                // Abrir/cerrar men√∫ de configuraci√≥n gr√°fica y mostrar coordenadas
                const graphicsMenu = document.getElementById('graphicsMenu');
                const coordsDisplay = document.getElementById('coordsDisplay');

                if (graphicsMenu.style.display === 'none' || !graphicsMenu.style.display) {
                    graphicsMenu.style.display = 'block';
                    coordsDisplay.style.display = 'block'; // Mostrar coordenadas
                    isMusicMenuOpen = true;
                    controls.unlock();
                } else {
                    graphicsMenu.style.display = 'none';
                    coordsDisplay.style.display = 'none'; // Ocultar coordenadas
                    isMusicMenuOpen = false;
                }
            }

            if (key === 'f') {
                let targetCar = null;

                // Si estamos dentro de un auto, siempre usar ese auto para el men√∫
                if (!isPlayerMode && currentCarId && loadedCars[currentCarId] && loadedCars[currentCarId].container) {
                    targetCar = loadedCars[currentCarId];
                } else {
                    const playerPos = controls.getObject().position;
                    let closestObj = null;
                    let closestDist = Infinity;

                    // Buscar en autos
                    Object.values(loadedCars).forEach(car => {
                        if (car.container) {
                            const d = playerPos.distanceTo(car.container.position);
                            if (d < closestDist) { closestDist = d; closestObj = car; }
                        }
                    });

                    // Buscar en decoraciones tipo RADIO
                    Object.values(loadedDecorations).forEach(dec => {
                        if (dec.radio && dec.container) {
                            const d = playerPos.distanceTo(dec.container.position);
                            if (d < closestDist) { closestDist = d; closestObj = dec; }
                        }
                    });

                    if (closestObj && closestDist < 10) {
                        targetCar = closestObj;
                    }
                }

                // Si no hay ning√∫n auto v√°lido, no abrir el men√∫
                if (!targetCar) {
                    return;
                }

                currentAudioTarget = targetCar.id;
                document.querySelector('#musicMenu h2').textContent = `üéµ Radio ${targetCar.name} - Bass Boost üéµ`;

                // Obtener valores actuales del objetivo (prioridad: valores actuales > estado guardado > valores por defecto)
                const target = loadedCars[currentAudioTarget] || loadedDecorations[currentAudioTarget];
                const audioObj = target ? target.audio : null;
                const state = carMusicState[currentAudioTarget];

                // Obtener volumen: primero del objeto de audio actual, luego del estado, luego default
                const vol = (audioObj && typeof audioObj.maxVolume === 'number')
                    ? audioObj.maxVolume
                    : (state && typeof state.volume === 'number')
                        ? state.volume
                        : 1.0;

                // Obtener sensibilidad: primero del objeto de audio actual, luego del estado, luego default
                const sens = (audioObj && typeof audioObj.bassSensitivity === 'number')
                    ? audioObj.bassSensitivity
                    : (state && typeof state.bassSensitivity === 'number')
                        ? state.bassSensitivity
                        : 0.5;

                // Obtener URL: del estado guardado
                musicUrl.value = (state && state.url) ? state.url : '';

                // Actualizar sliders con los valores actuales
                volumeSlider.value = Math.round(vol * 100);
                volumeValue.textContent = volumeSlider.value;
                bassSensitivitySlider.value = Math.round(sens * 100);
                bassValue.textContent = bassSensitivitySlider.value;

                // Asegurar que el objeto de audio tenga los valores correctos
                if (audioObj) {
                    audioObj.maxVolume = vol;
                    audioObj.bassSensitivity = sens;
                    if (audioObj.audioElement) {
                        audioObj.audioElement.volume = vol;
                    }
                }

                if (musicMenu.style.display === 'none' || !musicMenu.style.display) {
                    musicMenu.style.display = 'block';
                    isMusicMenuOpen = true;
                    controls.unlock();
                } else {
                    musicMenu.style.display = 'none';
                    isMusicMenuOpen = false;
                }
            }

            if ((key === 'e' || e.key === 'Enter')) {
                // 1. Manejar Sentado (Prioridad sobre autos)
                if (isSitting) {
                    standUp();
                    return;
                }

                if (isPlayerMode) {
                    const playerPos = controls.getObject().position;

                    // 2. Buscar silla cerca para sentarse
                    let closestSilla = null;
                    let sillaDist = Infinity;
                    Object.values(loadedDecorations).forEach(dec => {
                        if (dec.silla && dec.container) {
                            const d = playerPos.distanceTo(dec.container.position);
                            if (d < 3 && d < sillaDist) {
                                sillaDist = d;
                                closestSilla = dec;
                            }
                        }
                    });

                    if (closestSilla) {
                        checkSillaAvailability(closestSilla.id).then(isFree => {
                            if (isFree) {
                                sitDown(closestSilla.id);
                            } else {
                                document.getElementById('status').innerText = '‚ùå Silla ocupada';
                                setTimeout(() => {
                                    document.getElementById('status').innerText = 'Modo Jugador - F para m√∫sica';
                                }, 2000);
                            }
                        });
                        return;
                    }

                    // 3. Buscar auto para entrar
                    if (Object.keys(loadedCars).length > 0) {
                        let selectedCarData = null;
                        let closestDistance = Infinity;

                        Object.values(loadedCars).forEach(carData => {
                            if (carData.container) {
                                const distance = playerPos.distanceTo(carData.container.position);
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    selectedCarData = carData;
                                }
                            }
                        });

                        if (selectedCarData && closestDistance < 8) {
                            checkCarAvailability(selectedCarData.id).then(result => {
                                if (!result.canJoin) {
                                    document.getElementById('status').innerText = '‚ùå Auto lleno (m√°ximo 4 personas)';
                                    setTimeout(() => {
                                        document.getElementById('status').innerText = 'Modo Jugador - F para m√∫sica';
                                    }, 2000);
                                    return;
                                }

                                carRole = result.role;
                                currentCarId = selectedCarData.id;
                                isPlayerMode = false;
                                activeCarContainer = selectedCarData.container;
                                activeCarCollisionBox = selectedCarData.collisionBox;
                                activeCarBaseY = selectedCarData.baseY;

                                controls.unlock();
                                carSpeed = 0;
                                carRotation = selectedCarData.container.rotation.y;

                                const camPos = controls.getObject().position.clone();
                                scene.remove(controls.getObject());
                                camera.position.copy(camPos);
                                scene.add(camera);

                                if (carRole === 'driver') {
                                    document.getElementById('mode').innerText = `${selectedCarData.name} (Conductor)`;
                                    document.getElementById('status').innerText = 'üöó Manejando - F para m√∫sica';
                                } else {
                                    document.getElementById('mode').innerText = `${selectedCarData.name} (Pasajero)`;
                                    document.getElementById('status').innerText = 'ü™ë Pasajero - Solo disfrutas el viaje';
                                }

                                if (isOnline) {
                                    const occupantRef = ref(database, `carGame/${selectedCarData.id}Occupants/${currentPlayerId}`);
                                    set(occupantRef, {
                                        playerId: currentPlayerId,
                                        playerName: currentPlayerName,
                                        role: carRole,
                                        carId: selectedCarData.id,
                                        timestamp: Date.now()
                                    });
                                    onDisconnect(occupantRef).remove();
                                }
                            });
                        }
                    }
                } else if (activeCarContainer) {
                    // 4. Salir del auto
                    isPlayerMode = true;
                    carRole = null;
                    const wasCarId = currentCarId;
                    currentCarId = null;

                    const safeDistance = 6;
                    const carRot = activeCarContainer.rotation.y;
                    const exitX = activeCarContainer.position.x + Math.cos(carRot) * safeDistance;
                    const exitZ = activeCarContainer.position.z + Math.sin(carRot) * safeDistance;

                    scene.remove(camera);
                    controls.getObject().position.set(exitX, 1.7, exitZ);
                    scene.add(controls.getObject());

                    document.getElementById('mode').innerText = 'Jugador';
                    document.getElementById('status').innerText = 'Modo Jugador - F para m√∫sica';

                    activeCarContainer = null;
                    activeCarCollisionBox = null;

                    if (isOnline && wasCarId) {
                        remove(ref(database, `carGame/${wasCarId}Occupants/${currentPlayerId}`));
                    }
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();

            if (key === 'w') moveForward.active = false;
            if (key === 's') moveBackward.active = false;
            if (key === 'a') moveLeft.active = false;
            if (key === 'd') moveRight.active = false;

            if (e.key === 'ArrowUp') moveForward.active = false;
            if (e.key === 'ArrowDown') moveBackward.active = false;
            if (e.key === 'ArrowLeft') moveLeft.active = false;
            if (e.key === 'ArrowRight') moveRight.active = false;

            // Soltar Nitro
            if (e.key === 'Shift') {
                shiftKeyPressed = false;
                isNitroActive = false;
                nitroExhausted = false; // Al soltar Shift, se quita el bloqueo
            }
        });

        let carSpeed = 0;
        let carRotation = 0;

        // Sistema de Nitro
        let nitroAmount = 300; // Nitro inicial (0-300)
        const NITRO_MAX = 300; // Aumentado para m√°s duraci√≥n
        const NITRO_CONSUMPTION_RATE = 1.8; // Ajustado para balance
        const NITRO_RECHARGE_RATE = 1.0; // Recarga un poco m√°s lenta
        const NITRO_BOOST = 1.5; // Multiplicador de velocidad
        const MAX_CAR_SPEED = 1.2; // Velocidad m√°xima del auto aumentada (antes 0.8)
        let isNitroActive = false;
        let shiftKeyPressed = false;
        let nitroExhausted = false; // Bloqueo cuando se acaba el nitro

        let frameDelta = 1 / 60;
        let lastFrameTime = performance.now();
        const carNetVelocity = new THREE.Vector3(0, 0, 0);
        const CAR_NET_SPRING = 55;
        const CAR_NET_DAMPING = 12;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Funci√≥n para interpolar suavemente otros jugadores (OPTIMIZADA)
        function interpolateOtherPlayers() {
            // Rastrear QU√â JUGADOR est√° manejando QU√â AUTO din√°micamente
            const carDrivingData = {};
            const lerpFactor = 0.15;
            const velocityDecay = 0.9;
            const predictionTime = 0.12;

            Object.keys(otherPlayers).forEach(playerId => {
                const player = otherPlayers[playerId];
                if (player.targetPos && player.model) {
                    // Optimizar: reutilizar c√°lculos
                    const velScaled = player.velocity.clone().multiplyScalar(predictionTime);
                    const predictedPos = player.targetPos.clone().add(velScaled);

                    // Interpolar posici√≥n del jugador caminando
                    player.model.position.lerp(predictedPos, lerpFactor);

                    // Si est√° en modo auto, guardar datos para ESTE auto espec√≠fico
                    if (player.data.mode === 'car') {
                        const playerCarId = player.data.carId || 'car1';
                        carDrivingData[playerCarId] = {
                            predictedPos: predictedPos,
                            rotation: player.targetRotation,
                            carId: playerCarId
                        };
                    }

                    // Reducir velocidad gradualmente
                    player.velocity.multiplyScalar(velocityDecay);
                }
            });

            // Controlar TODOS los autos din√°micamente
            Object.values(loadedCars).forEach(carData => {
                if (carData.container) {
                    // Si YO estoy manejando ESTE auto, no sobre-escribir
                    if (!isPlayerMode && carRole === 'driver' && currentCarId === carData.id) {
                        // YO lo manejo, skip
                        return;
                    }

                    if (carDrivingData[carData.id]) {
                        // OTRO jugador lo est√° manejando
                        const drivingData = carDrivingData[carData.id];
                        const carTarget = drivingData.predictedPos;
                        const carPos = carData.container.position;

                        const dx = carTarget.x - carPos.x;
                        const dz = carTarget.z - carPos.z;

                        carNetVelocity.x += dx * CAR_NET_SPRING * frameDelta;
                        carNetVelocity.z += dz * CAR_NET_SPRING * frameDelta;

                        const dampingFactor = Math.exp(-CAR_NET_DAMPING * frameDelta);
                        carNetVelocity.x *= dampingFactor;
                        carNetVelocity.z *= dampingFactor;

                        carData.container.position.x += carNetVelocity.x * frameDelta;
                        carData.container.position.z += carNetVelocity.z * frameDelta;

                        // Optimizar rotaci√≥n
                        const currentRot = carData.container.rotation.y;
                        const targetRot = drivingData.rotation;
                        let rotDiff = targetRot - currentRot;
                        // Normalizar √°ngulo
                        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                        carData.container.rotation.y = currentRot + rotDiff * lerpFactor;
                    }
                }
            });
        }

        // Variables para optimizaci√≥n
        let lastStatusUpdate = 0;
        const STATUS_UPDATE_INTERVAL = 500; // Actualizar status cada 500ms
        let lastClosestCarCheck = 0;
        const CLOSEST_CAR_CHECK_INTERVAL = 200; // Verificar auto cercano cada 200ms
        let cachedClosestCar = null;
        let cachedClosestDistance = Infinity;

        // Variables para LOD y visibilidad
        let lastLODUpdate = 0;
        const LOD_UPDATE_INTERVAL = 100; // Actualizar LOD cada 100ms
        // Las distancias LOD se definen globalmente arriba para que applyGraphicsQuality funcione

        // 8. LOOP DE ANIMACI√ìN
        function update() {
            requestAnimationFrame(update);

            const now = performance.now();
            frameDelta = Math.min(0.05, (now - lastFrameTime) / 1000);
            lastFrameTime = now;

            if (isPlayerMode) {
                if (isSitting) {
                    // Si estamos sentados, solo permitimos mirar (no actualizar direcci√≥n ni velocidad)
                    direction.set(0, 0, 0);
                    velocity.set(0, 0, 0);
                } else {
                    direction.z = Number(moveForward.active) - Number(moveBackward.active);
                    direction.x = Number(moveRight.active) - Number(moveLeft.active);

                    // Solo normalizar si hay movimiento
                    if (direction.x !== 0 || direction.z !== 0) {
                        direction.normalize();
                    }

                    if (moveForward.active || moveBackward.active) {
                        velocity.z = direction.z * playerSpeed;
                    } else {
                        velocity.z = 0;
                    }

                    if (moveLeft.active || moveRight.active) {
                        velocity.x = direction.x * playerSpeed;
                    } else {
                        velocity.x = 0;
                    }

                    // Solo verificar colisi√≥n si hay movimiento
                    if (velocity.x !== 0 || velocity.z !== 0) {
                        const currentPos = controls.getObject().position.clone();
                        controls.moveRight(velocity.x);
                        controls.moveForward(velocity.z);
                        const newPos = controls.getObject().position;
                        if (checkCarCollision(newPos)) {
                            controls.getObject().position.copy(currentPos);
                        }
                    }
                }

                if (!isSitting) {
                    controls.getObject().position.y = 1.7;
                }

                // Optimizar: solo buscar auto cercano cada cierto tiempo
                if (now - lastClosestCarCheck > CLOSEST_CAR_CHECK_INTERVAL) {
                    lastClosestCarCheck = now;
                    cachedClosestCar = null;
                    cachedClosestDistance = Infinity;

                    // Buscar el auto m√°s cercano din√°micamente
                    Object.values(loadedCars).forEach(carData => {
                        if (carData.container) {
                            const distance = controls.getObject().position.distanceTo(carData.container.position);
                            if (distance < cachedClosestDistance) {
                                cachedClosestDistance = distance;
                                cachedClosestCar = carData;
                            }
                        }
                    });
                }

                // Actualizar status solo cada cierto tiempo para reducir DOM updates
                if (now - lastStatusUpdate > STATUS_UPDATE_INTERVAL) {
                    lastStatusUpdate = now;
                    const statusEl = document.getElementById('status');

                    const isCloseToCar = (cachedClosestDistance < 5 && cachedClosestCar);

                    if (isCloseToCar) {
                        statusEl.innerText = `Presiona E para entrar al ${cachedClosestCar.name}`;
                    } else if (statusEl.innerText.includes('Presiona E')) {
                        statusEl.innerText = 'Modo Jugador - F para m√∫sica';
                    }

                    // L√≥gica M√≥vil UI (MOVIDA)
                    if (false && typeof isMobile !== 'undefined' && isMobile) {
                        const enterBtn = document.getElementById('mobileEnterBtn');
                        const carControls = document.getElementById('mobileCarControls');
                        // El joystick es managed por nipplejs, se oculta el contenedor padre o visualmente
                        const joystickZone = document.getElementById('joystickZone');
                        const actionBtn = document.getElementById('mobileActionBtn');

                        if (isPlayerMode) {
                            // Modo Caminar
                            if (carControls) carControls.style.display = 'none';
                            if (joystickZone) joystickZone.style.display = 'block';
                            if (actionBtn) actionBtn.style.display = 'flex';

                            // Bot√≥n de puerta solo si cerca de auto
                            if (enterBtn) {
                                enterBtn.style.display = isCloseToCar ? 'flex' : 'none';
                            }
                        } else {
                            // Modo Auto
                            if (carControls) carControls.style.display = 'block';
                            if (joystickZone) joystickZone.style.display = 'none';
                            if (actionBtn) actionBtn.style.display = 'none'; // Ocultar bot√≥n F

                            // Bot√≥n puerta siempre visible para salir
                            if (enterBtn) enterBtn.style.display = 'flex';
                        }
                    }
                }

            } else {
                if (activeCarContainer && carRole === 'driver') {
                    // Solo el conductor puede controlar el auto
                    if (moveForward.active) carSpeed += 0.015; // Aceleraci√≥n aumentada (antes 0.01)
                    if (moveBackward.active) carSpeed -= 0.015;
                    if (moveLeft.active) carRotation += 0.035; // Giro un poco m√°s √°gil
                    if (moveRight.active) carRotation -= 0.035;

                    // Sistema de Nitro
                    const nitroBarContainer = document.getElementById('nitroBarContainer');
                    const nitroBar = document.getElementById('nitroBar');
                    const speedEffect = document.getElementById('speedEffect');

                    // Mostrar barra de nitro cuando est√°s manejando
                    nitroBarContainer.style.display = 'block';

                    // Sistema de Nitro con bloqueo (hay que soltar Shift si se acaba)
                    const canActivateNitro = !nitroExhausted && (nitroAmount > 10 || (isNitroActive && nitroAmount > 0));

                    if (shiftKeyPressed && canActivateNitro && moveForward.active) {
                        isNitroActive = true;
                        nitroAmount = Math.max(0, nitroAmount - NITRO_CONSUMPTION_RATE * frameDelta * 60);

                        // Si llega a 0, activar bloqueo de agotamiento
                        if (nitroAmount <= 0) {
                            isNitroActive = false;
                            nitroExhausted = true;
                        }

                        // Aplicar boost de velocidad (limitado)
                        const speedBoost = 1 + (NITRO_BOOST - 1) * (nitroAmount / NITRO_MAX);
                        carSpeed *= speedBoost;

                        // Limitar velocidad m√°xima
                        if (carSpeed > MAX_CAR_SPEED) {
                            carSpeed = MAX_CAR_SPEED;
                        }

                        // Efectos visuales
                        nitroBarContainer.classList.add('active');
                        speedEffect.classList.add('active');

                        // Efecto de c√°mara (ligero zoom y movimiento)
                        camera.fov = THREE.MathUtils.lerp(camera.fov, 72, 0.1);
                        camera.updateProjectionMatrix();
                    } else {
                        isNitroActive = false;
                        nitroBarContainer.classList.remove('active');
                        speedEffect.classList.remove('active');

                        // Restaurar FOV normal
                        camera.fov = THREE.MathUtils.lerp(camera.fov, 75, 0.1);
                        camera.updateProjectionMatrix();

                        // Recargar nitro si no est√° activo
                        if (nitroAmount < NITRO_MAX) {
                            nitroAmount = Math.min(NITRO_MAX, nitroAmount + NITRO_RECHARGE_RATE * frameDelta * 60);
                        }
                    }

                    // Actualizar barra de nitro
                    // Actualizar barra de nitro (convertir de 0-200 a 0-100%)
                    nitroBar.style.width = `${(nitroAmount / NITRO_MAX) * 100}%`;

                    // Fricci√≥n normal (ajustada para que no pierda tanta velocidad)
                    const friction = isNitroActive ? 0.94 : 0.965; // Menos fricci√≥n = m√°s velocidad final
                    carSpeed *= friction;

                    // L√≠mite de velocidad adicional (seguridad)
                    if (Math.abs(carSpeed) > MAX_CAR_SPEED) {
                        carSpeed = Math.sign(carSpeed) * MAX_CAR_SPEED;
                    }

                    activeCarContainer.rotation.y = carRotation;
                    const sinRot = Math.sin(carRotation);
                    const cosRot = Math.cos(carRotation);
                    activeCarContainer.position.x += sinRot * carSpeed;
                    activeCarContainer.position.z += cosRot * carSpeed;

                    // Optimizar: reutilizar c√°lculos trigonom√©tricos
                    const camOffset = new THREE.Vector3(
                        activeCarContainer.position.x - sinRot * 12,
                        activeCarContainer.position.y + 5,
                        activeCarContainer.position.z - cosRot * 12
                    );
                    camera.position.lerp(camOffset, 0.1);
                    camera.lookAt(activeCarContainer.position);
                } else if (activeCarContainer && carRole === 'passenger') {
                    // Pasajero: c√°mara sigue el auto pero no controla
                    carSpeed *= 0.95;
                    carRotation = activeCarContainer.rotation.y;
                    const sinRot = Math.sin(carRotation);
                    const cosRot = Math.cos(carRotation);

                    const camOffset = new THREE.Vector3(
                        activeCarContainer.position.x - sinRot * 12,
                        activeCarContainer.position.y + 5,
                        activeCarContainer.position.z - cosRot * 12
                    );
                    camera.position.lerp(camOffset, 0.1);
                    camera.lookAt(activeCarContainer.position);
                } else {
                    // Ocultar barra de nitro cuando no est√°s en un auto
                    document.getElementById('nitroBarContainer').style.display = 'none';
                    document.getElementById('speedEffect').classList.remove('active');
                }
            }

            // Ocultar barra de nitro cuando est√°s en modo jugador (si no est√°s en auto)
            if (isPlayerMode) {
                document.getElementById('nitroBarContainer').style.display = 'none';
                document.getElementById('speedEffect').classList.remove('active');
            }

            // Actualizar efectos de audio y rebote (siempre para asegurar resets suaves de posici√≥n)
            updateAudioVolume();
            updateCarBounce();

            // --- L√≥gica de Radiobox ---
            updateRadioBoxes();

            // Interpolar posiciones de otros jugadores para movimiento suave
            if (Object.keys(otherPlayers).length > 0) {
                interpolateOtherPlayers();
            }

            // Actualizar LOD y visibilidad (optimizado: solo cada cierto tiempo)
            if (now - lastLODUpdate > LOD_UPDATE_INTERVAL) {
                lastLODUpdate = now;
                updateLODAndVisibility();
            }

            // Actualizar visualizaci√≥n de coordenadas si el men√∫ est√° abierto
            if (isMusicMenuOpen) {
                let p;
                if (isPlayerMode) p = controls.getObject().position;
                else if (activeCarContainer) p = activeCarContainer.position;

                if (p) {
                    document.getElementById('coordsDisplay').innerText = `üìç X: ${p.x.toFixed(2)} | Y: ${p.y.toFixed(2)} | Z: ${p.z.toFixed(2)}`;
                }
            }

            // --- Sincronizaci√≥n Multiplayer ---
            updateMyPosition();

            renderer.render(scene, camera);
        }

        // Funci√≥n para actualizar LOD y visibilidad basado en distancia
        function updateLODAndVisibility() {
            // Obtener posici√≥n del jugador
            let playerPos;
            if (isPlayerMode) {
                playerPos = controls.getObject().position;
            } else if (activeCarContainer) {
                playerPos = activeCarContainer.position;
            } else {
                return;
            }

            // Actualizar LOD de autos
            Object.values(loadedCars).forEach(carData => {
                if (carData.container && carData.container.userData.meshes) {
                    const distance = playerPos.distanceTo(carData.container.position);

                    // Si est√° muy lejos, ocultar completamente
                    if (distance > VISIBILITY_DISTANCE) {
                        carData.container.visible = false;
                        // Tambi√©n ocultar accesorios externos (radioBox y cable)
                        if (carData.radioBox) carData.radioBox.visible = false;
                        if (carData.radioCable) carData.radioCable.visible = false;
                        return;
                    }

                    carData.container.visible = true;
                    // (La visibilidad de radioBox se maneja en updateRadioBoxes, pero aqu√≠ aseguramos el culling por distancia)

                    // Aplicar LOD basado en distancia
                    const meshes = carData.container.userData.meshes;
                    meshes.forEach((mesh, index) => {
                        if (!mesh.material) return;

                        // Mantener sombras activas siempre (solo desactivar si est√° muy muy lejos)
                        // Las sombras son importantes visualmente, as√≠ que las mantenemos activas
                        if (distance > VISIBILITY_DISTANCE * 1.5) {
                            // Solo desactivar sombras si est√° extremadamente lejos
                            mesh.castShadow = false;
                            mesh.receiveShadow = false;
                        } else {
                            // Mantener sombras activas en la mayor√≠a de casos
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                        }

                        // Reducir calidad de geometr√≠a a distancia (simplificar materiales) pero mantener sombras
                        if (distance > LOD_DISTANCE_FAR) {
                            // Muy lejos: mantener sombras pero simplificar material
                            if (mesh.material && mesh.material.isMeshStandardMaterial) {
                                mesh.material.roughness = 1.0; // Material m√°s simple
                            }
                        } else {
                            // Restaurar material original si est√° disponible
                            if (mesh.material && carData.container.userData.originalMaterials) {
                                const originalMat = carData.container.userData.originalMaterials[index];
                                if (originalMat) {
                                    mesh.material = originalMat;
                                }
                            }
                        }
                    });
                }
            });

            // Actualizar LOD de decoraciones
            Object.values(loadedDecorations).forEach(dec => {
                if (dec.container) {
                    const distance = playerPos.distanceTo(dec.container.position);

                    // Visibilidad simple por distancia para objetos grandes
                    // AHORA RESPETA STRICTAMENTE LA VISIBILITY_DISTANCE (sin multiplicar x2)
                    if (distance > VISIBILITY_DISTANCE) {
                        dec.container.visible = false;
                        return;
                    }
                    dec.container.visible = true;

                    // Sombras din√°micas seg√∫n distancia
                    if (dec.meshes) {
                        dec.meshes.forEach(mesh => {
                            mesh.castShadow = (distance < VISIBILITY_DISTANCE);
                        });
                    }
                }
            });


            // Mobile UI Logic (Inserted)
            if (typeof isMobile !== 'undefined' && isMobile) {
                const enterBtn = document.getElementById('mobileEnterBtn');
                const carControls = document.getElementById('mobileCarControls');
                const joystickZone = document.getElementById('joystickZone');
                const actionBtn = document.getElementById('mobileActionBtn');
                const crosshair = document.getElementById('crosshair');

                if (isPlayerMode) {
                    if (carControls) carControls.style.display = 'none';
                    if (joystickZone) joystickZone.style.display = 'block';
                    if (actionBtn) actionBtn.style.display = 'flex';
                    if (crosshair) crosshair.style.display = 'block'; // Mostrar cruz caminando

                    // Verificar cercan√≠a a Autos (cachedClosestDistance) O Sillas
                    let isClose = (typeof cachedClosestDistance !== 'undefined' && cachedClosestDistance < 9); // Usar rango 9 como configuramos

                    // Si no estamos cerca de un auto, chequear sillas
                    if (!isClose && typeof loadedDecorations !== 'undefined') {
                        const pPos = controls.getObject().position;
                        for (const key in loadedDecorations) {
                            const dec = loadedDecorations[key];
                            if (dec.silla && dec.container && pPos.distanceTo(dec.container.position) < 4) {
                                isClose = true;
                                break;
                            }
                        }
                    }

                    if (enterBtn) enterBtn.style.display = isClose ? 'flex' : 'none';
                } else {
                    if (carControls) carControls.style.display = 'block';
                    if (joystickZone) joystickZone.style.display = 'none';
                    if (actionBtn) actionBtn.style.display = 'none';
                    if (crosshair) crosshair.style.display = 'none'; // Ocultar cruz en auto
                    if (enterBtn) enterBtn.style.display = 'flex';
                }
            }

            renderer.render(scene, camera);
        }

        update();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>

</html>
